#title Welcome
* 15年3月7日 周六 23:41

** [iOS] 被逼的 VFL

把几年前的 app demo 搬出来，当年还没有 5、5s、6、6p 的时候，界面的布局是
简单的，可是这两年 duang 一下出来了这么多新机器，现在 iOS 下屏幕分辨率的
分裂程度也是让人目瞪口呆。

当年一个控件 xib 就可以横行天下，5、5s 出来后有些控件不得不加了一个 xib，
6、6p 出来后，我想我有时是拒绝使用 xib 了，妹的 6 跟 6p 的分辨率都没什么
关联嘛。

官方的说法 5、5s、6 都是 2x，6p 是 3x，并且为动态的控件还加了 autosize，
可这玩意儿我不懂用。

学着在 xib 里面使用 constraints，总是达不到自己想要的效果，折腾了好久好
久，腰酸背痛是真的。

看了一下官方那一页 VFL，第一次感觉到不知所云。于是上 github 找替代品，比
如 ''''PureLayout，用了一下，使用上有些限制，且效果仍然不是我想要的。

说一下我要的效果，table view cell 里面放多张方形图片，portrait 跟
landscape 下布局不一样，前者 space | image | space | image | fixed space，
后者是三个 image，而且我还考虑 6p 下面多加一个 image。如果我选择 xib，不
是累死。

即便 ''''PureLayout，还需要我指定中间间隔 space 的宽度，可我想这不是需要动态
计算的吗，如果我能知道这个宽度的值，我都可以自己计算 frame 的大小咯，还
要constraints 干嘛，我都 specify 了。

我不明白的是，当年 CSS 都可以指定某个标签具体位置的百分比，方位，为啥水
果的 VFL 不行呢，看起来 ''''PureLayout 也不好使呀，比如第三个例子，我想要的
效果还有距离。

于是又 baidu、bing VFL 的资料，官网又硬着头皮看了一下，终于有点开窍了，
后来发现其实 VFL 是简单的。

它的基础是所有需要动态伸缩的东西，都是一个 UIView（我是这么理解的），所
有的数值，都是固定的，要么是间隔，要么是相互关系，比如宽是高的两倍。

这就清楚了，其实官方 VFL 里面的 Spacing and Wrapping 举的例子就很清晰了，
我上面要的效果里面，space 都是 UIView，动态计算就好。

指定三个 image 宽、高相等，三个 image 的宽都相等，多个 space 的宽都相等，
然后在指定 image 的高度（Y值）就足够了，后面 fix space 就不需要一个
UIView 了，可以直接指定了。


相比之下，感觉到是 IB 里面的 constraits 反而操作复杂了，而且经常是说限制
不够，运行又出错什么的。

可是明明二维的坐标，x、y 可以确定的话，那个东西就固定了呀，IB 会有让我找
不着北的感觉，且里面的 constraints 也不容易看出来，太乱。

相比之下 VFL 就好很多，只是概念不好说清，比如那个 space，我是先入为主，
觉得为啥不能像 CSS 一样，直接指定 UIView 的位置呢，谁能想到即便官方的文
档里面，需要动态计算大小的元素，只能是 UIView。

写了一点 VFL 后，github 上又找了 Auto Layout Shorthand，但貌似不是完全的
映射，它自己封装了一些东西，只能作罢。

所以我也简单封装了自己的一些东西，试用了一个小时，感觉还不错，也放到 gist 上面
了。

<code type="objc">
// formula as 'width == width'
static NSLayoutConstraint*
_lcItemRel(UIView *v1, NSString *formula, UIView *v2, float ratio, float constant) {
    static NSDictionary *attrValueForName = nil;
    static dispatch_once_t attrOnceToken;
    dispatch_once(&attrOnceToken, ^{
        attrValueForName =
        @{
          @"left":      @(NSLayoutAttributeLeft),
          @"right":     @(NSLayoutAttributeRight),
          @"top":       @(NSLayoutAttributeTop),
          @"bottom":    @(NSLayoutAttributeBottom),
          @"leading":   @(NSLayoutAttributeLeading),
          @"trailing":  @(NSLayoutAttributeTrailing),
          @"width":     @(NSLayoutAttributeWidth),
          @"height":    @(NSLayoutAttributeHeight),
          @"centerX":   @(NSLayoutAttributeCenterX),
          @"centerY":   @(NSLayoutAttributeCenterY),
          @"baseline":  @(NSLayoutAttributeBaseline),
          };
    });
    
    static NSDictionary *relationValueForName = nil;
    static dispatch_once_t relationOnceToken;
    dispatch_once(&relationOnceToken, ^{
        relationValueForName =
        @{
          @"==":  @(NSLayoutRelationEqual),
          @">=":  @(NSLayoutRelationGreaterThanOrEqual),
          @"<=":  @(NSLayoutRelationLessThanOrEqual),
          };
    });
    
    NSArray *kv = [formula componentsSeparatedByString:@" "];
    
    NSLayoutAttribute a1, a2;
    NSLayoutRelation r;
    
    if (kv[0]==nil || kv[1]==nil || kv[2]==nil) {
        return nil;
    }
    
    a1 = (NSLayoutAttribute)[((NSNumber*)attrValueForName[kv[0]]) integerValue];
    a2 = (NSLayoutAttribute)[((NSNumber*)attrValueForName[kv[2]]) integerValue];
    r = (NSLayoutRelation)[((NSNumber*)relationValueForName[kv[1]]) integerValue];

    return [NSLayoutConstraint constraintWithItem:v1
                                        attribute:a1
                                        relatedBy:r
                                           toItem:v2
                                        attribute:a2
                                       multiplier:ratio
                                         constant:constant];
}

static NSArray*
_lcAryOfVFL(NSString *formula, NSLayoutFormatOptions opt, NSDictionary *metric, NSDictionary *views) {
    return [NSLayoutConstraint
            constraintsWithVisualFormat:formula
            options:opt
            metrics:metric
            views:views];
}
</code>

gist 地址，https://gist.github.com/lalawue/430102f68327fe302964, 请自备
梯子。（最后又发现了个不错的 [[https://github.com/floriankugler/FLKAutoLayout][FLKAutoLayout]]，不过没用过，具体就不知道了)

*** [[CategoryProgramming][CategoryProgramming]] / [[2015-03#p1][Permalink]]

<!-- date: 2015-03-07T23:41:59+0800 -->

* 15年3月7日 周六 23:22

** 播放器使用 OpenAL 需要注意的

扯一下写在线视频播放器使用 OpenAL 遇到过的坑吧。

由于不涉及到 listener 的位置与加速度，openal 参数的设置是简单的，且仅仅
只需要一个 source，一定量的 buffer，加上 streaming 的操作。

第一个问题来了，streaming 的操作，多个 buffer，可具体需要多少个呢，这个
还真不好说。我做过一些边界测试，不过没那么详细，iOS 真机还是模拟器上面，
总共可以开到 512 个 buffer name，这个数量总该够了吧。

或者，buffer 固定数量，自己先缓存一定量再扔进去，这样就解决了 buffer
name 不够的问题。我这边播放 1M 多的码流，每个 audio packet 大概 8k，可以
算出来自己需要缓存多少时间。

第二个问题，其实是 OpenAL 默认的情况，就是 queue 上去的 buffer，播放完毕，
到达 stop 的状态后，新的 buffer queue 进来，其实仍然是 queue 到这些
buffer 的后面去，一旦设置成 play 状态，会先播放一遍已经 stop 的旧数据。

这个 bug 瞒了我很久，因为我之前的 seek 有些问题，加上 audio cache 又不多，
现象不明显。

这意味每次 queue 新的 buffer 进去之前，把里面的 processed buffer 都给
unqueue 先才行，这绝壁是个坑啊，哪有 stop 后还赖着不走的。

第三个问题，processed 后的 buffer name，其实在 C 的操作里面，不好存到已
有的 buffer 数组里面，得新开一个 free_buffer name 的数组，来存放已经
processed 的 buffer name，要不然这些 buffer name 会丢失，再想扔新的数据
时就找不到它了。

如果无论如何都先 queue 完已申请的 buffer name，然后再取 processed 的，就
能避免这个问题。可这又溶于遇到第二个问题，我就是这么绕进去的。

典型的 API 足够简单，但是使用小别扭的问题。OpenAL 我是参考了 1.1 的
specification，对于写视频播放器足够了，iOS 上官方说是低阶 API，性能足够，
且又跨平台，何求？

*** [[CategoryProgramming][CategoryProgramming]] / [[2015-03#p0][Permalink]] 

<!-- date: 2015-03-07T23:22:57+0800 -->

* 15年2月28日 周六 23:44

** IUP & vs2012

过年在家搭建了 app 的 win 服务端，create install 免费版打包，已经可以使
用了。

架构方面，两个程序组成，都是 win32 api，不需要依赖 dot net。

网上抄的一个 win32 任务栏图标代码，在此基础上加入了之前的跨平台服务端线
程，就跑起来了。

设置界面用的是 IUP 界面库，一个支持 win、gtk、motif 的框架，事件驱动，要
比基础的 win32 gdi 编程好太多，而又不需要依赖 dot net。

之前为了 IPC 通信，还尝试使用了 mail slot，不过当时我的架构不是很好，出
了不少问题，最后也没有继续用下来去，而是直接 findwindow，通过标题栏、
class name 匹配，然后 post message 来通信，感觉也足够了。

学习使用 iup 也花了一些时间，相比之下，为了让 vs2012 支持 xp 而弄的各种
调试，简直让人吐血。

后来我是放弃了 vs2012，改用 vs2010，xp 可是不能放弃的。vs2010 还必须安装
sp1 才行，否则编译下来各种问题，即便是 sp1，也不是每次编译都能顺利通过。

一个 sp1 补丁包就 1.5G，也够吐血的。


*** [[CategoryProgramming][CategoryProgramming]] / [[2015-02#p1][Permalink]] 

<!-- date: 2015-02-28T23:44:09+0800 -->

* 15年2月14日 周六 00:38

** [iOS] dispatch_after

忙活的网络播放器有了眉目，音视频同步起来了，之前的问题，在于 audio 播放
一直很不顺利，总是偶尔会卡，或者嗤嗤地想，我一直单独地认为是 audio 播放
的问题，或者是 OpenAL 管理 buffer 的问题。

当然后来也发现 OpenAL 的 buffer 管理也是需要注意的，比如建立了 64 个
buffer，做 streaming，最好是都先全部 queue 上去，再 query 哪些已经
processed，之后 buffer data，之后再 re queue；而不是先 queue 一部分，
query 无 processed 之后，queue 新的 buffer，iOS 上面者会造成嗤地噪声，估
计是 OpenAL 管理的问题。

当然 OpenAL 在我这里还有一些未解决的问题，以后再说吧。

接着说不同步的部分，更多的是时钟不同步造成的，也就是延时。

比如主时钟一般都是 video 管着的，而 video 每一帧时间跨度要比 audio 大多
了，一秒才小几十帧，每一帧稍微拖延或快一点，其实我们人眼不敏感，而 audio
呢，普通的 22k 都是差的音频，一般 44.1k，或者 48k，这个时钟相比 video 部
分就要求很精确了，当然这部分其实都是硬件管着，封装出来的 OpenAL 接口也简
单，扔 buffer 进去就行。

问题在于 video 管时钟，video 拖延一点，我们人眼觉得 video 还正常，但是怎
么 audio 就那么刺耳了呢，其实是 audio 的 buffer 数据跟不上了。

在 iOS 平台上面，是 dispatch_after 等这些延时的函数时间非常不精确，虽然
是以 nano seconds 为单位的，但是这个单位只是说能够延时的最小单位，而并不
是精确到这个单位，这两者是有很大区别的。

所以 AV 同步部分就得做很多的时间检测以及补偿，如果是 video 主时钟，就补
偿 video，并不是为了人眼看得舒服（其实真看不出来），而是为了 audio 能够
顺利同步，两边的 buffer 都能够平衡。


*** [[CategoryProgramming][CategoryProgramming]] / [[2015-02#p0][Permalink]] 

<!-- date: 2015-02-14T00:38:00+0800 -->

* 15年1月30日 周五 12:42

** 有关 GLFW

这段时间做的项目是使用 GLFW 来做跨平台的播放器，大体上框架已经好了，音视
频也同步了，大概花了快两周时间，然后也是今天才知道 cocos2dx 3.x 系列是用
glfw 来做 opengl 窗口管理的，我是没有继续深究了，不过因为看到这个，忽然
有种我选得没错的感觉。

GLFW 横跨 Mac/Win/Linux 三个平台，提供基于 OpenGL 渲染窗口，消息机制，这
点很不错，大体上统一了三个平台基础 OpenGL 的创建，销毁，以及鼠标、键盘消
息。

我之前因为想学习 OpenGL，看到的很多国内教程都是 glut 来入门，而且还是
OpenGL 2.x 系列的 API，实际上，现在都已经是 3.x 系列的 API 了，当然系统
总是向下兼容的，老的 API 也能用就是。

若是现在开始涉及到桌面 OpenGL 部分的，强烈推荐呀。

*** [[CategoryProgramming][CategoryProgramming]] / [[2015-01#p2][Permalink]] 

<!-- date: 2015-01-30T12:42:25+0800 -->

* 15年1月15日 周四 01:34

** 获取默认网卡的 IP 地址

目前在做一个简单的服务端程序，需要客户端发现服务端的 IP 地址，然后请求链
接。发现部分是用 UDP 的广播来做了，但是服务端获取 IP 地址部分，遇到了问
题。

服务端里面 TCP bind 时，地址是可以为 INADDR_ANY 的，意味着不管是哪个网络
过来的数据，只要路由到系统，端口对应上，我的服务端程序就可以 accept。看
起来美好，但是流程上走不通，这时候程序其实是不知道 IP 包是从哪个网卡过来
的，所以即便接收到了客户端的 UDP 广播请求，也仍然无法发送可以连接的 IP
地址给客户端，因为从系统里面获取地址的 getsockname() 获取的其实是之前
bind 的地址，也就是 &#34;0.0.0.0&#34;。

路由都已经通了，但却无法获取路由过的网卡 IP 地址。如果这一切都只能通过之
前的 bind 来显式地指定只接收某个网络过来的包，确实是太折腾了。

简单点，不如就是用系统默认网卡的 IP 地址好了，至少系统保证这个是最为可用
的地址。

MacOS 下获取系统网络设备名称以及地址跟 Linux 下的相似，都是 getifaddrs()，
搜到了一篇中文介绍；然后获取系统默认网卡的信息，我是从 stackoverflow 上
面搜到的。

 - [[http://www.cnblogs.com/sammei/p/3955679.html][getifaddrs]]
 - [[http://stackoverflow.com/questions/4872196/how-to-get-the-wifi-gateway-address-on-the-iphone][How to get the WIFI gateway address on the iPhone?]]

这样，bind 的时候仍然可以为 INADDR_ANY，客户端 UDP 广播请求的时候，服务
端大方发送可连接的 IP 地址。扯远点，复杂点的情况，多个网卡，多个异构网络，
服务端可以根据具体的请求发送不同的 IP 地址，只要能路由过来，都可以
accept。

大概就是这个意思了吧。

*** [[CategoryProgramming][CategoryProgramming]] / [[2015-01#p1][Permalink]] 

<!-- date: 2015-01-15T01:34:41+0800 -->

* 15年1月3日 周六 11:19

** HTTP Downloader

忙了两天多那个 [[https://github.com/lalawue/http_downloader][HTTP Downloader]]，原来只是想实现一个 keep-alive 的连接的
socket，当时也想到这个东西不会简单，因为一方面底层的是 low level 的
socket，另外一方面呢，需要处理一层 http 协议，还有一个 dns。

后来是因为找到了 dns 的代码，就开工了，才发现复杂呀，一方面 c 的部分我觉
得我大意了，编码不够小心，各种折腾。

另外就是 c 的 string 库太不好用了，所以不得不封装了一个，至少得有 split
这个函数吧，没有的话啥都不用玩了。

其实大概一天不到基本的 http get 已经完成了，只是代码太糟糕，我觉得需要改
进一下，最主要的就是 string 库，于是昨天折腾了快一天呀，代码清晰了很多。

这个 string 库是有 gc 的，从 head 操作产生的其他 object，都会随着 head
的 destroy 而 destory。新建 head 的 interface 就那么几个，很有限，所以其
实可以在开始复杂操作时新建 head，之后后清除掉那个入口的 head。

新建 head 的接口除了 malloc 一段 cstring，还可以 map 一段 cstring 地址给
它作为操作的空间，这时候内部标记 clone，就是这个 mstring 的 cstr 地址不
是自己保存的，之后的 destroy 不用释放这个空间，对于像 http head 或者
body 的分析时，这个就很有用了。

由于新建 mstring 的空间其实是堆上的，对于各种小操作时产生的 mstring，不
大好，还不如 cloudwu 那个栈上的方式，栈上的方式新建轻松，而且没有碎片的
产生。

不过呢，就是得随时注意，这些栈上的对象何时销毁，需要的时候需要转成堆上的
对象。

我有个想法，其实这些小碎片，不如申请一个专用的堆来操作，比如这个堆绑定在
head 的 allocator 上，从 head 产生的所有 object 都是用这个 allocator，这
样就避免了大量的小对象，对于内存碎片的控制是有益的，特别是对于那种 map
cstring 过来的对象，因为本身 cstring 空间是不用释放的，这时候就很有用了，
因为 mstring 自己控制用的结构，空间占用不大。

不过呢，新建的 heap 多大才有用而又不至于浪费，那就又是另外一回事了，以及
这个接口如何提供的问题，这个想法还得斟酌一下。

*** [[CategoryProgramming][CategoryProgramming]] / [[2015-01#p0][Permalink]] 

<!-- date: 2015-01-03T11:19:57+0800 -->

* 14年12月29日 周一 10:22

** My First Mac App - ''''TcBrowserMac

开始练习 Mac App 的编写，与 iOS App 有许多不同，昨天花了一天时间，山寨了
一个 ''''TcBrowser，一个筛选算法题目的小软件，作者博客页面
[[http://zh.lucida.me/blog/top-code-offline-browser/][Top Coder算法题目浏览器]]。

也许是我没有深入开发的原因，感觉不再像 iOS 一样，需要多个 View
Controller 了，使得我一开始就考虑模块划分的问题，虽然这个软件是个小工具
而已。

然后考虑像 win 一样，可以在文件夹下面打开访问当前文件夹的目录，由于 Mac
是打包成 bundle 来跑的，界面上的 app 其实是个文件夹，所以我之前整的方法
都不对，需要通过 [[NSBundle mainBundle] bundlePath] 来获取。

然后 ''''StoryBoard 方面，由于软件是个窗口，所以大小是可变的，一开始就得考虑
自动布局的问题，Apple 文档那边对于自动布局长篇大论不说，还有一个用于自动
布局的 DSL，足够复杂了，昨天时间有限，我是没有看透。

实际是用 ''''StoryBoard 点击 nib 后 Editor -> Resolve Auto Layout Issues 上
面的 Add Missing Constraints 来做的，每添加一个控件，就要 Add 一次。

然后感觉还跟控件添加的顺序有关系，Xcode 会猜测这个控件到底是对齐那一边，
依据的是 superview 还是哪个 view，这些 constraints 在 inspector 里面几乎
不能配置，我本来一个 webview 靠右是要左对齐的，然后右边让它跟着
superview 无限扩展，可是如果给弄成右对齐就改不了了，反正我是没弄懂怎么改，
所以我只好把 constraints 删除又添加一遍。

然后是 tableview，与 iOS 也有些不同，没有了 cell 的概念，取而代之的是
NSView，没有了 index，而是一个 ''''NSTableColumn 的结构，table column 的
identifier 可以设置，重用时也是依据这些 identifier。不过 column 的
header title 我折腾了不少时间，然后是宽度也是通过 column 设置的。

跟 iOS 一样，只需要设置两个函数就可以让数据上来了，一个是
numberOfRowsInTableView，一个是 viewForTableColumn。

最后是软件图标的问题，感觉与 iOS 也不一样，也许是我之前没有那么正规军的
原因。我是想要 Dock 上面自定义图标，谷歌到的方法也只是动态设置的而已，关
闭的时候很明显会显示回默认的那个。

实际上呢，需要设置的方法在 [[https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Optimizing/Optimizing.html#//apple_ref/doc/uid/TP40012302-CH7-SW3][Apple Doc - Optimizing for High Resolution]]，
具体是需要下面几个大小的图标，然后放到 icon_name.iconset 这个文件夹下面

<example>
icon_16x16.png
icon_16x16@2x.png
icon_32x32.png
icon_32x32@2x.png
icon_128x128.png
icon_128x128@2x.png
icon_256x256.png
icon_256x256@2x.png
icon_512x512.png
icon_512x512@2x.png
</example>

终端下使用命令

<src type="sh">
$ iconutil -c icns icon_name.iconset
</src>

 来生成，然后拖到工程文件里面就好了，默认就是那个图标了，这个也折腾了不
 少时间 ，第一个 Mac App 终于完成了，地址在这里 [[http://pan.baidu.com/s/1sjv3gNN][TcBrowserMac]]，密码是宇宙终极答案。



*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p6][Permalink]] 

<!-- date: 2014-12-29T10:22:03+0800 -->

* 14年12月27日 周六 17:58

** ObjC Animation

其实去年在做那个 App 的时候就有使用过简单的动画，接口是 UIView 的
animateWithDuration，只是平移了一下 view。

今天学到的 iOS 的动画，分成几个部分，分别是针对 view 的，针对 controller
的过渡动画，还有就是自由度很高的交互动画，交互动画其实可以看成是最简单的
游戏了。

针对 view 的动画除了我之前用的 animateWithDuration 方法，其实 view 的很
多属性都是可以更改数值然后交给系统去实现动作的，只需要创建 animation 设
置动画属性，然后使用 view 的 layer 实体 addAnimation 就好。

view 中的 layer 需要说一下，为了实现动画，有多个副本，一个是表示最终状态
的（model layer），一个是表示的是当前的（presentation layer），
presentation 是专门用来显示动画的，结束后就被设成了 model 的状态。

后面例子的还用画图实现了一个动画，画图部分就纯是 CPU 来计算了。另外一个
部分是 controller 的转场动画，例子比我之前的平移复杂了一些，用了系统给出
的 delegate 接口来设置，总之这也是可以自定义的。

还有最后的可交互动画，实际上就跟游戏没啥区别了，动画部分的数值需要不断根
据用户的交互来获取、计算，然后设置具体的显示，这些计算实际上是在显示驱动
的每一帧间隔里面做的。

cocos2dx 的底层部分也是通过 display link 来驱动实现每一帧的画图与计算，
然后用户的输入是通过 UIView 的 ''''UIKeyInput delegate 来做的，而不像这个例
子通过手势控件 recognizer 来做的， cocos2dx 的方式更灵活一些，不过两者对
于动画显示、操作最底层的部分是相似的。

没想到两者后底层部分的驱动结构其实是一样的，display link 与 run loop。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p5][Permalink]] 

<!-- date: 2014-12-27T17:58:25+0800 -->

* 14年12月25日 周四 22:16

** ObjC Core Data

Core Data 市面上的文章太多，不管是中文还是英文，所以打算以自己的理解从简
描述。

先从上到下、从大到小理解概念。关键的概念其实只有 4 个：

 - ''''NSManagedModel：数据模型，数据的结构
 - ''''NSManagedModelContext：具体存取增删数据的接口
 - ''''NSPersistentStoreCoordinator：连接 context 与 persistent store 的中间
   件
 - ''''NSPersistentStore：数据库，具体的文件

如果还要简约，那概念上只需要关注 model 跟 store 就可以了，一个是 schema，
模型结构，比如一张表，另一个是数据库，具体到文件。

描述概念间相互关系的图表网上太多，我简略看了一下接口，了解到的是目前 8.1
的 SDK下，一个 context 对应一个 model 和一个 coordinator，一个
coordinator 可以连接多个 store，相互的关系可以脑补了吧。

下面的代码只要建立一个 ''''TestCoreData 的头文件调用一下最下面的 test 就可以
编译跑了，粗看有点多，其实分开函数看就好了，函数名很直白了。

<src type="objc">
@interface UserInfo : NSManagedObject
@property (nonatomic,copy) NSString *name;
@property (nonatomic,copy) NSNumber *uid;
@end

@implementation UserInfo
@dynamic name;
@dynamic uid;
@end

@implementation TestCoreData
- (NSURL*)createStoreDir
{
    NSFileManager *fm = [[NSFileManager alloc] init];
    NSError *error = nil;
    NSURL *durl = [fm URLForDirectory:NSDocumentDirectory
                             inDomain:NSUserDomainMask
                    appropriateForURL:nil
                               create:YES
                                error:&error];
    if (durl == nil) {
        NSLog(@"Fail to create document dir:%@", [error localizedDescription]);
        return nil;
    }
    return durl;
}

- (NSManagedObjectModel*)createModel
{
    NSManagedObjectModel *moModel = [[NSManagedObjectModel alloc] init];
    
    // create the entity
    NSEntityDescription *infoEntity = [[NSEntityDescription alloc] init];
    [infoEntity setName:@"UserInfo"];
    [infoEntity setManagedObjectClassName:@"UserInfo"];
    
    [moModel setEntities:[NSArray arrayWithObject:infoEntity]];
    
    // add the attribute
    NSAttributeDescription *nameAttr = [[NSAttributeDescription alloc] init];
    [nameAttr setName:@"name"];
    [nameAttr setAttributeType:NSStringAttributeType];
    [nameAttr setOptional:NO];
    
    NSAttributeDescription *uidAttr = [[NSAttributeDescription alloc] init];
    [uidAttr setName:@"uid"];
    [uidAttr setAttributeType:NSInteger32AttributeType];
    [uidAttr setOptional:NO];
    
    // set the properties for the entity
    NSArray *ary = [NSArray arrayWithObjects:nameAttr, uidAttr, nil];
    [infoEntity setProperties:ary];
    
    // add localization dictionary
    NSMutableDictionary *localDict = [NSMutableDictionary dictionary];
    [localDict setObject:@"name" forKey:@"Property/name/Entity/UserInfo"];
    [localDict setObject:@"uid" forKey:@"Property/uid/Entity/UserInfo"];
    
    [moModel setLocalizationDictionary:localDict];
    
    return moModel;
}

- (NSManagedObjectContext*)createModelObjectContext:(NSManagedObjectModel*) moModel
{
    NSManagedObjectContext *moMOC = [[NSManagedObjectContext alloc] init];
    NSPersistentStoreCoordinator *co =
           [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:moModel];
    
    [moMOC setPersistentStoreCoordinator:co];
    
    NSString *store_type = NSBinaryStoreType; // NSSQLiteStoreType
    NSString *store_filename = [NSString stringWithFormat:@"storeExample.bin"];
    
    NSError *error = nil;
    NSURL *store_url = [[self createStoreDir]
           URLByAppendingPathComponent:store_filename];
    
    NSLog(@"store url: %@", [store_url absoluteString]);

    NSPersistentStore *pstore = [co addPersistentStoreWithType:store_type
                                                 configuration:nil
                                                           URL:store_url
                                                       options:nil
                                                         error:&error];
    if (pstore == nil) {
        NSLog(@"Fail to create persistence store %@", [error localizedDescription]);
        return nil;
    }
    return moMOC;
}

- (BOOL)test
{
    NSManagedObjectModel *moModel = [self createModel];
    NSManagedObjectContext *moMOC = [self createModelObjectContext:moModel];
    
    NSEntityDescription *infoEntity =
          [[moModel entitiesByName] objectForKey:@"UserInfo"];
    
    // insert
    int i;
    for (i=0; i<10; i++) {
        UserInfo *info = [[UserInfo alloc] initWithEntity:infoEntity
                           insertIntoManagedObjectContext:moMOC];
        info.name = [NSString stringWithFormat:@"n%d", i];
        info.uid = [NSNumber numberWithInt:i];
    }
    
    // save
    NSError *error = nil;
    [moMOC save:&error];
    if (error) {
        NSLog(@"Fail to save: %@", [error localizedDescription]);
        return false;
    }
    
#if 1
    // query & delete
    NSFetchRequest *req = [[NSFetchRequest alloc] init];
    [req setEntity:infoEntity];
    
    NSSortDescriptor *sdesc = 
          [[NSSortDescriptor alloc] initWithKey:@"uid" ascending:YES];
    [req setSortDescriptors:[NSArray arrayWithObject:sdesc]];
    
    NSArray *ary = [moMOC executeFetchRequest:req error:&error];
    if (error && (ary==nil)) {
        NSLog(@"Fail to fetch object: %@", [error localizedDescription]);
        return false;
    }
    for (UserInfo *info in ary) {
        NSLog(@"user info name:%@, uid:%d", info.name, [info.uid intValue]);
        [moMOC deleteObject:info];
    }

    // save again
    [moMOC save:&error];
    if (error) {
        NSLog(@"Fail to save: %@", [error localizedDescription]);
        return false;
    }
#endif
    return true;
}
@end
</src>

更具体细节的东西，比如 Predicates、搜索结果的缓存，可以需要的时候再细查
了，有了重要概念、框架的支撑，往下往细里面走就好办了吧。

明天玩玩新的东西。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p4][Permalink]] 

<!-- date: 2014-12-25T22:16:40+0800 -->

* 14年12月24日 周三 15:29

** NSThread、''''NSRunLoop、GCD、__block

因为想求职 Objective-C 开发的原因，被问到了一些很基础的问题，而我做 iOS
App 已经是一年以前的事情，且也没有那么系统地学习过，所以就慢慢把这些补齐。

我是从 POSIX 的 pthread 入门了解多线程的，用过 mutex 这些临界区保护的方
法，对于 Mac Objective-C 这边的多线程，对应的是 NSThread。

建立多线程是为了同步做一些事情，不影响界面的响应等等，这些事情要么是纯计
算的，要么是各种事件的处理，对于这些事件的检测以及处理，Objective-C 是放
到 ''''NSRunLoop 里面去的，感觉跟满足了 select 以及 epoll 条件下的大括号块差
不多吧。

''''NSRunLoop 就是一个内部循环的结构，一定是从属于某个线程的，要么是属于主线
程，要么是属于自己创建的线程。

下面的例子是建立了一个 ''''NSRunLoop 响应一秒一次的 NSTimer，这个 ''''NSRunLoop
是跑在一个单独的线程（非主线程）里的。

<src type="objc">
- (void)timer_entry:(NSTimer*)t
{
    NSLog(@"timer is main thread %d", [NSThread isMainThread]);
}

static int _newThreadAborted;

- (void)thread_entry:(id)param
{
    NSLog(@"enter thread");
    @autoreleasepool {
        NSTimer *t = [NSTimer timerWithTimeInterval:1
                                              target:self
                                            selector:@selector(timer_entry:)
                                            userInfo:nil
                                             repeats:YES];
        NSRunLoop *r = [NSRunLoop currentRunLoop];
        [r addTimer:t forMode:NSDefaultRunLoopMode];
        while (!_newThreadAborted) {
            [r runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
            NSLog(@"should not reach here until loop ending");
        }
        NSLog(@"thread aborted");
    }
}

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification {
    // Insert code here to initialize your application
    
    NSLog(@"is main thread %d", [NSThread isMainThread]);
    
    NSThread *t = [[NSThread alloc] initWithTarget:self selector:@selector(thread_entry:) object:nil];
    [t start];
}
</src>

上面的例子 ''''NSRunLoop 添加了一个 NSTimer 事件源，同样的可以添加其他的事件
源，比如鼠标、键盘的，这样就可以在某个线程的 ''''NSRunLoop 里面处理具体的事
情了，且不影响主线程。

如果 ''''NSRunLoop 里面 while 了一个死循环，这个线程就做不了其他事情了。如果
这个 ''''NSRunLoop 是在主线程里面，界面就会卡住，一个 NSThread 里面只能有一
个 ''''NSRunLoop，新建立的线程会在调用获取 ''''NSRunLoop 的时候创建。

而 GCD （Grand Central Dispatch） 我觉得中文网络上面的信息挺不错的，也许
也是因为自己之前已经使用了不少了吧，也因为使用的简单，所以当时的项目里面
也让我不需要去关注 NSThread 跟 ''''NSRunLoop 了。

具体的使用其实就是构建一个闭包函数，跟 Lua 里面的闭包效果一样，所以这样
的函数也可以作为值传递了。

比较需要注意的是栈上的闭包函数与堆上的闭包函数的区别，其生命周期是不一样
的。

另外就是闭包内部访问外部的变量值，若是栈上的变量，则是取建立闭包时的值，
若无 __block 修饰，则是建立闭包函数时拷贝到闭包结构里面的值，这个变量在
闭包内部与外部已经没有文法上的联系了，具体表现就是闭包内部修改不影响外面
的变量，外部的修改不影响闭包内部同名的变量。

若加了 __block 修饰，则在文法上面，两者是联系在一起的，闭包内部以及上下
文可以访问到的地方都可以修改，具体的存储地址呢则看闭包是放在栈上还是堆上
了，也就是这个变量实际是跟随闭包的变量。

对了，其实还有全局区的闭包，我觉得只要区别不是栈上的闭包就好了。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p3][Permalink]] 

<!-- date: 2014-12-24T15:29:33+0800 -->

