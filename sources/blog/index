#title Welcome
* 17年12月2日 周六 11:49

** More Than Human

​​这几天接连看了几个机器人相关的报道，比如后空翻的 [[https://cn.engadget.com/2017/11/17/boston-dynamics-atlas-robot-backflip/][这个]]，以及[[https://cn.engadget.com/2017/11/14/boston-dynamics-spotmini/][机器狗]]，不得
不感叹就机体性能而言，这个进化速度实在太快了，如果再考虑能量效率，就更不
用说。

想起前一阵子看的[[https://movie.douban.com/review/8888093/][《银翼杀手2049》]]，复制人K随着故事不断推进逐渐丰满，最后
让我隐约觉得某种意义上他比人类更像人类。

在现实中，随着软（硬）件行业不断重新规范整个人类社会，机器能接受、处理信
息的能力越来越强，逐渐数字化的社会将越来越有效率，只是这样的迭代发展真的
太恐怖。

完全数字化的社会，代表着未来人类从摇篮开始，将方方面面被数字包围，我们的
每一个毛孔、每一个行为都将被数字所记录、表达，数字就是我们，我们就是数字。

我们现在就已经非常依赖于这些流动的信息，它们太方便，太智能，太有效率。只
是这些流动的信息，会让我们不知不觉生活在楚门的世界。没有数字化的信息，甚
至被认为是不够准确、真实的。

这些信息的重要，在于它记录了我们的过去、预测我们的将来。所谓的过去，不只
是过去的行为，它们还将深入了解我们的基因，我们上一代的方方面面；所谓的将
来，不只是我们当下可能的选择，还有我们未来的方向。

这些信息，包含了我们坐椅的高低，空调的温度、鞋子的尺码、衣服的款式及材质、
软硬舒服程度、上班的时间线路、午饭的餐品喜好，我们获取信息的方式、跟陌生
人打交道的方法，还有每天跟父母、恋人的电话次数、说的每一句话、在微信里发
的每一个字、每一个表情，我们会如何表达爱意，期待着对方的回应是有趣、深邃、
严肃、活泼、认真、机智、幽默、浓烈、冷淡、走心还是走肾的。

我们会很开心、并最后习惯于每天这么方便的生活，每一句谈话都这么舒服，每一
次交流都这么温暖，再好的上帝也不过如此吧。可也许我们有意无意间终会知道，
我们所面对的，可是掌握了我们相关的所有信息，体测500KM起，几乎不休息，也
不挑食，一顿饭的时间以秒计，吃完了可以再跑500KM的机器人。

在任何一个方面，人家可根本不把我们看在眼里。​​​​​


*** [[CategoryReading][CategoryReading]] / [[2017-12#p0][Permalink]] 

<!-- date: 2017-12-02T11:49:07+0800 -->

* 17年9月5日 周二 00:59

** 有关 m_net 跨平台的小型网络库

最近一直在玩 [[https://github.com/lalawue/m_net][m_net]]，当然总是处于修修改改当中。

很早就有参考 [[https://github.com/rxi/dyad][dyad]] 这个优雅到不行的网络库，C89 的语法，接口设计清晰明了；
仅针对 TCP 抽象为 Stream；对于 socket 的状态变化，设置为事件监听接收处理；
简单粗暴的 SDK 接收数据再发通知，buffer 地址以及数据 size 直接送到用户手
上，接收部分则随着数据增大，而不断 realloc 出来；读写接口还加上了方便的
基于 C string 的处理。

基于这一套网络库构造的 demo，简明得不行，比如首页的 echo server。

且后者还提供了 timer。这个 timer 的实现，其实基于 select 对于阻塞 socket
的监听。

m_net 历史，最早是从 13 年做游戏时弄的一个单独处理 socket 的接口，当时写
得很挫先不说。后来慢慢发展，看到了 dyad 后，大量参考了 dyad 的设计。比如
抽象了 win 下的接口，使用 select 处理三个平台的 socket 事件，不同的是，
一开始就包含了 TCP、UDP 的支持，一开始就是非阻塞的接口，对于 socket 则命
名为 channel，简称 chann。

但后来 m_net 在不同平台采用了 kqueue、epoll 的实现，接口以及处理上就很不
同了，代码量也增加了很多。状态关注点少了不少，从事件数量上就可以看出来。

最近 m_net 的更改，是将 C 这一层的接口整理了一下，增加了两个 utils。一个
是用于 resolve host 的函数处理 host name 到 ip 的转化（DNS）；另外是单独
对于 ip:port 这样的字串，加入一个 parse 的接口，分割拿到 ip 跟 port。

把 C 的这一层命名为 core 之后，在 C 接口的基础上，抽象了 C++ 的 wrapper
对象，有三种 ''''ChannAddr，Chann 和 ''''ChannDispacher。

分别用来处理地址部分，chann 的数据、状态处理，以及所有 chann 的事件监听、
分发。抽象的结果，是在 C++ 这一层，比如针对 client、server 的处理，可以
类似 C 一样设置一个事件函数，或者继承 Chann 父类，封装专门处理 client、
server 的子类，所有的事件、数据都在子类的内部流转，容易理解，易看易懂。

C++ 支持了闭包后，单纯的 listen 接口不需要外建函数，或者派生子类，只需构
造一个闭包处理就好，方便了很多。

但是跟 dyad 还是有很大差距的，巨大的差距，在于对于数据的处理，m_net 不会
在 recv 事件（数据到达）的时候帮用户接收数据，所以用户任何时候去 recv 数
据，都需要自己准备一个 buffer，跟平常的 socket recv、send 没有什么不同。

这个代码量就出来了，且 buffer 处理的优雅与否，比如针对不同的 protocol 抽
象，是巨大的考验，我目前没有好的想法。

暂时是不想跟 dyad 一样帮用户处理了，我觉得这样也不好，比如不断读取然后
append 到已有的 buffer 上，大小不够了向系统要，不断 realloc 也很颓。

m_net 没有对 recv 先接收处理，但是对于 send 部分，如果 socket 只是反馈
would block，而不是其他的不可恢复的 error，则 SDK 会构造 buffer 存入用户
数据，待 socket 可写后再慢慢 drain 数据。

目前没有设置阈值，上层可以一直写，一直到内存耗尽，不知道底层其实 socket
虽未断开但已经无法写入很久很久了。

可以考虑设置某个阈值，比如 16M 的时候，给上层一个 EAGAIN 之类的，目前先
不管。

另外重要 feature，比如 timer 部分目前是没有的，由于所有 socket 都是非阻
塞，如果仅仅在事件循环的时候获取当前时间，并走一次 timer chain，极端情况
下，CPU 时间片占用是很可观的，这也是我一开始避免加入 timer 的原因。

如果要加入 timer，那在这种情况下，我觉得，需要定一个最小的时间分割，一次
循环，不多不少，就走一个 timer circle，比如 10ms，每 10ms 获取一次事件，
或者多次循环获取一次，然后矫正，这个问题不大。

这种方案下，CPU 时间片占用方面才可以接受，上层事件的精确度也能够保证。

只是目前 timer 部分接口，如果 mnet_poll() 上面增加调用，感觉也不不是很好，
毕竟很多时候，是不需要这个 timer 的。目前一个 -1 的值设过去，有事件就突
击处理一下，没事件就死等待好了。

所以 timer 部分的接口，是集成在 mnet_poll() 之上，还是给用户一个选择，单
独的设置并处理，还需要斟酌一下。


*** [[CategoryProgramming][CategoryProgramming]] / [[2017-09#p0][Permalink]]

<!-- date: 2017-09-05T00:59:18+0800 -->

* 17年8月20日 周日 11:36

** 短信自动转发机

好早之前因为办理宽带，才知道天威视讯跟联通是一家，也才知道联通收了话费说
能拉宽带，而天威可以接着说拉不了。

所以我最后是进入了电信的坑，这条宽带也拉得很不容易，电信分几个不同的业务
部，一个是营业厅，另外一个是电话 10000 号业务，营业厅说拉不了，但是
10000 号也许业务很缺，说可以。最后我是跟着一个电信小哥花了半个小时横跨两
层楼拉了一条电话线上来，然后终于光纤入户了。

带来的问题是，我多了一个月流量 4G 的电信号码。这是两年以前，不久流量可以
流转后，每个月手头有近 8G 流量。

可是水果家的机子，只能装一张卡，没有流量玩什么手机，流量高的先包养起来，
于是我装上了电信卡。联通卡仅剩下呼叫转移、短信转发的工作，变成了低保机。
比较蛋疼的是短信，当时不懂自动短信转发，一开始带的是两个手机。

后来是用 HTC_M8 装了一个第三方 APP，后台收短信，转发到相应公众号，我这边微信
到相应公众号注册接收，一条一分钱。

问题是这个后台太耗电了，一开始 HTC_M8 只负责呼叫转移，可以待机 4+ 天，加
了这个后台 APP，只能待机近一天。备机吃起电来堪比主机，服侍不动，累瘫。

而且还有安全问题，联通是主力注册号，在第三方小服务商眼皮底下过短信，总觉
得太不靠谱。

后来才知道水果家的 iMessage 可以同一个账号收发，但是要 8.0 及之上的系统。
前一阵子我刚露了一手，给吃灰好久的 4S 装上了淘宝新电池，第二春蓄势待发。
可还是 7.1 的系统，Home 键也坏了。还好水果爸爸心慈，有 ''''AssistiveTouch，
还答应可以升级到 9.3.5。

小小设置了一番，电话转移也有了，短信收发也有了，延迟很小，完全可以接受，
安全性要比之前的好太多。耗电方面，实测带着淘宝新电池的 4S，可以妥妥地扛
3 ～ 4 天，这个结果相比之前，不能更开心。

*** [[CategoryMisc][CategoryMisc]] / [[2017-08#p2][Permalink]] 

<!-- date: 2017-08-20T11:36:36+0800 -->

* 17年8月11日 周五 02:09

** 本站换域名了

换成 http://suchang.org 了，域名商还是原来那个，查到 github 只能绑定一个
domain 吧，于是换了，这样旧的 http://suchang.net 就无法访问了。

前几天 gmail 收到一些域名降价邮件，随手查了一下，马上把这个域名给捞了。
记得之前在大学时，好想抢这个，可惜抢不到，现在是没人要了。

此一时彼一时。

*** [[CategoryThisSite][CategoryThisSite]] / [[2017-08#p1][Permalink]] 

<!-- date: 2017-08-11T02:09:22+0800 -->

* 17年8月6日 周日 13:34

** m_kcptun

之前的 [[https://github.com/lalawue/m_tunnel][m_tunnel]] 因为基于 TCP，实际环境单独使用其实不尽如人意，因为 TCP
本身重发机制等等原因，在网络环境比较糟糕的情况下，延迟长得让人难以接受。

早期的改进，诸如在手机、PC 端的动作游戏，IM 上，是使用改进的 UDP，封装自
己的协议，以及重发机制管理，来达到速度、带宽的平衡。

比较有名的是 [[https://github.com/skywind3000/kcp][kcp]]，包含完整协议，意图取代 TCP，野心更大的则是 Google 的
[[https://www.chromium.org/quic][QUIC]] 协议，还包含完整的安全性的考虑。

上面也说到，其实很早之前大家就都有基于 UDP 的各自的方案，大家对 TCP 的局
限也都比较清楚，所以类似 QUIC 这样的协议，感觉铺开会很快的。

实际上，我自己使用 m_tunnel 是使用 [[https://github.com/xtaci/kcptun][kcptun]]，要不实际环境跑起来太慢了，再
说自己也想研究一下 kcp 的使用，于是构建了这个
https://github.com/lalawue/m_kcptun 。

目前仅能完成基础的工作，离具体实用还有一段距离，因为实际上虽然基于 kcp，
上层还是需要自己的协议，来模拟这端 TCP 与远端 TCP 是否还连上这个问题，起
码能保证当本地 TCP 重连的时候，远端 TCP 也来一个断开重连，要不然，跑在
TCP 上面的协议会乱的。


*** [[CategoryProgramming][CategoryProgramming]] / [[2017-08#p0][Permalink]] 

<!-- date: 2017-08-06T13:34:04+0800 -->

* 17年6月25日 周日 00:30

** m_tunnel 支持 epoll/kqueue

[[https://github.com/lalawue/m_tunnel][m_tunnel]] 支持 epoll/kqueue 了，所以默认情况下，Win 下编译使用 select 模
型，Linux 下使用 epoll，MacOS 下使用 kqueue。这样的话，Linux 及 MacOS 下
都没有了 socket 数量的限制，虽然大部分的情况下不会遇到这种问题。

自用 m_tunnel 一段时间了，配合 kcptun 使用很不错，觉得将 kcp 集成到
m_tunnel 里，这个选项可以提上日程了，当代实际能用时又不知到什么时候了。

另外，将 m_tunnel 里面网络的部分单独抽取出来，放到了 [[https://github.com/lalawue/m_net][m_net]] 里，修改了一
些 API，增加了一个 ERROR 的状态，另外，增加了 example 以及 test 文件。

epoll、kqueue 虽然使用平台不一样，但是其接口是类似的，较大的不同，在于对
于 socket 的通知属性修改，epoll 的接口是单独对某个 socket 设置，而
kqueue 的接口是通过 kevent API 来操作一个数组，在接口使用上，我感觉后者
更好一些。

*** [[CategoryProgramming][CategoryProgramming]] / [[2017-06#p0][Permalink]] 

<!-- date: 2017-06-25T00:30:16+0800 -->

* 17年5月7日 周日 10:36

** 安装黑苹果 10.12 macOS Sierra

想想距离上次安装已经有一年多了，这次升级安装，原因是之前查到 10.11 下对
GTX 1060 无法支持，这是个太大的硬伤。考虑到之前几次升级安装，也还算顺利，
这次没多想就开干了，但这次巨蛋疼，来来回回花了近三天时间，通了一次宵才搞
定。

这次黑苹果安装，把 Clover 的普通安装、启动引导安装，EFI 系统分区，系统安
装盘，DSDT，相关工具的使用，以及这个版本安装的其他坑弄清楚了一些。

回头想想，如果要达到一个类似 Windows 安装流程那样顺利的安装，需要了解上
面的这些概念才行，然后还需要用到下面列出来的工具，要不然，随便碰到一点现
象，就不知道该怎么办了，那就难了。

比如所谓的懒人版，应该是加了一些驱动吧，但我觉得在普适性上面，也还是会挑
硬件的，苹果的系统，本来就没有考虑过这一点，从需要第三方的引导器如 Clover，
以及需要 DSDT 来看就知道了。

还有，我之所以不用懒人版，还是担心安全性的问题。


**** 一、安装前提

 - PC macOS 独立硬盘安装，支持 64 位的硬件，支持 UEFI 启动的主板
 - 需要设置 BIOS，需要插拔独立显卡
 - 不懂我说啥的同学，非 64 位硬件非 UEFI 的同学，其他非独立硬盘想双系统
   的同学，这里帮不了你了


**** 二、需要的工具

下面列出需要的工具，但一些工具需要在 macOS 下运行，只有 Windows 的考虑下
其他替代工具吧，需要的工具有：

 - MaciASL.app，用于生成 DSDT 描述文件

 - Clover Configurator.app，用于配置 Clover，以及挂载 EFI 分区

 - 最新版的 Clover，到 sourceForge 下就好

 - AGDPfix.app，用于解决部分 SMBIOS 接 Nvidia 显卡后启动显示黑屏的问题，
   有其他的替代方案，可通过搜这个 app 看看（这个驱动独立显卡，安装后使用
   的）

另外，需要一个 8G 或者更大容量的 U 盘，以及需要对主板 BIOS 进行以下设置：

 - Secure Boot disable
 - AHCI enable
 - UEFI enable（可以选择 UEFI、legacy 都支持）
 - XHCI ''''SmartAuto
 - XHCI/EHCI handoff enable
 - 设置 U 盘启动优先级最高

上面的设置来源于外文网站，我自己也是这么设置的，那些懒人版都没有这个说明
的。由于对部分开关不了解，所以这里不展开描述。

我自己电脑的大概信息是 3 个硬盘，一个单用于 Windows，一个单用于 macOS 的
最新版本（就是这次准备安装的），一个是备份启动的 macOS 系统（10.11.6），
只有这个不是 SSD，也分区用于存数据资料。上面的 BIOS 设置，对 Windows 系
统没有影响。


**** 三、准备资源

这里列一下大概需要准备的资源，创建硬件描述表 DSDT，准备安装用的 U 盘

 - 10.12 macOS Sierra 原版安装盘，并创建系统安装 U 盘

 - 最新版的 Clover，先给系统安装 U 盘创建 Clover 启动，务必在安装界面勾
   选自定（customize），选择安装启动引导以及 Drivers64UEFI 下
   的''''OsxAptioFixDrv-64

 - 使用 MaciASL.app 生成 DSDT，并编译，遇到编译不过的问题，将这一行或这
   一块删除，直到通过编译，保存为 AML 二进制文件

 - 使用 Clover Configurator.app 挂载 U 盘的 EFI 分区（请注意不是当前启动
   macOS 的 EFI 分区），将 DSDT 描述文件放到 EFI/ACPI/patched 以及
   origin 下面

 - 下载最新版的 FakeSMC.kext 放到 U 盘 EFI/CLOVER/kexts/Others 下面，
   kexts 目录下如果还有其他文件夹的，建议将 10.12 文件夹下面的也拷贝到
   Others，然后删除掉除 Others 的其他，要不每次升级系统都得拷贝一遍，麻烦

 - 使用 Clover Configurator.app 配置 U 盘 EFI 分区下的 config.plist，
   boot 下面的 verbose、x86_64、xcpm、kext-dev-mode=1、nv_disable=1 勾选；
   SMBIOS 里面点魔术棒选个跟当前硬件配置差不多的就好；还有 Kernel 下的
   AppleRTC 勾选；或者用你当前 Clover 的配置也行，但是要去掉独立显卡的选
   项

 - 关闭保存 Clover Configurator.app 并推出 U 盘 EFI 分区


**** 四、安装流程

先说一下大概的流程，U 盘启动安装，遇到问题增添 U 盘 EFI 分区的 kext，安
装后修复部分 SMBIOS 下的黑屏问题。

 1. 如果有像我这样 Nvidia GTX 1060 显卡的，先把显卡拔掉，BIOS 设置使用 Intel
    内置显卡

 2. BIOS 设置 U 盘启动优先级最高，使用 U 盘 Clover 启动安装，如果没有
    kext 挂掉，kernel panic，那么可以走到安装界面；选择盘符抹盘安装

 3. 安装顺利完成，使用 U 盘引导并启动到新版系统，先驱动起网卡，然后下载
    Nvidia 的 web 驱动安装，并使用 AGDPfix.app 修正部分 SMBIOS 设置的黑
    屏问题

 4. 使用 Clover 给新版系统安装启动引导，将之前 U 盘的 EFI 分区内容拷贝到
    新系统的 EFI 分区，修改 config.plist，去掉 nv_disable=1，加入
    nvidiaweb 支持（请看这一节的最后），保存并推出 EFI 分区

 5. 关机下电，将 Nvidia 独立显卡插回主板，修改 BIOS 的启动顺序

 6. 顺利启动新系统，安装结束；其他 kext 安装、声卡、网卡驱动安装，Clover
    默认启动项请搜索其他吧

有关 nvidiaweb 驱动的支持，需要使用文本编辑器编辑 config.plist，在
''''SystemParameters key 下添加：

<example>
	<key>SystemParameters</key>
	<dict>
                ... 其他配置 ...
        	<key>NvidiaWeb</key>
        	<true/>
	</dict>
</example>


**** 五、kernel panic、黑屏问题

这里的 kernel panic 出现在安装第 2. 步，我也遇到过，看看是什么 kext 引起
的，将其更新或删除就好，一般有了 DSDT 后，对硬件的描述应该不成问题了。

Clover 可以修改启动参数，在 Option 里面，选择启动参数，enter 后修改，一
般是增加减少 -v，nv_disable=1，-x，-f 之类的。

黑屏问题看外文参考资料是因为 SMBIOS 设置，苹果针对 OEM 单独做的处理，请
看下面的英文参考资料。


**** 六、参考资料

参考外文资料比较好，比如 www.tonymacx86.com

 - [[https://www.tonymacx86.com/threads/good-news-for-x99-10-11-haswell-e-el-capitan.178425/page-4#post-1151520][Clover 设置及黑屏问题]]
 - [[https://www.tonymacx86.com/threads/black-screen-with-macpro-6-1-or-imac-15-or-imac-17-system-definition.183113/][Black Screen with MacPro 6,1 or iMac 15 or iMac 17 System Definition]]


*** [[CategoryLinux][CategoryLinux]] / [[2017-05#p0][Permalink]] 

<!-- date: 2017-05-07T10:36:03+0800 -->

* 17年4月16日 周日 22:52

** m_tunnel 支持 Win7

其实 [[https://github.com/lalawue/m_tunnel][m_tunnel]] 使用单 TCP 来连接本地、远端有风险，就是 TCP 本身并不是为流
速设计的，而是为流量设计的，这使得很多请求，在 TCP 网络不稳定的时候，很
容易就被卡住，而这里本身的设计，就使得后一个请求，跟前一个请求发生了关联，
要卡大家一起卡。

这个大 BUG 是最开始设计的问题，后来就想转而使用 KCP 来做中间的管道，而不
是使用 TCP，当然当时也有不少使用 KCP 的类似工具了。

最近是看上了 [[https://github.com/xtaci/kcptun][kcptun]]，一个使用 kcp 来做管道的工具，管道还需要配上两端的
shadowshocks，来为浏览器等提供标准的 socks5 接口，以及对应远端发起真实的
请求。而我则刚好可以使用 m_tunnel 来替代 shadowsocks。加入 Win7 的支持，
则是因为现在玩游戏比较多了，算了一下，在 Win7 下面的时间更多。

还好，用 VS2017 建立工程编译，需要修改的东西不多，就可以跑了，效果是杠杠
的，当然，m_tunnel 是用的是 select 来实现 MacOS、Linux、Windows 三端接口
一致，而不是 libuv 这类框架。

使用 select，就有一些效率的问题，但如果不是做极端的 server，其实是没有关
系的，这个我也有一些 CPU 使用量的数据；还有就是 socket 同时使用的数量是
有限制的，但是对于一般人来说，其实都足够了，因为你真的很难很难能够同时用
完 select 提供的最大 socket 数量。

我这边也提供了一个 Win7 的 [[https://github.com/lalawue/m_tunnel/releases/download/v20170415/mtunnel_local_windows_amd64.zip][precompiled 版本]]，自己则是买了 Linode 东京每
月 5 刀的套餐，在 SZ 看 Youtube 720P 几乎秒开，大概这样。

*** [[CategoryProgramming][CategoryProgramming]] / [[2017-04#p1][Permalink]] 

<!-- date: 2017-04-16T22:52:47+0800 -->

* 17年4月16日 周日 22:42

** emacs-wiki-mode 已死

为这个静态站点更新了几个链接，RSS 地址，还有搜索地址，这个站点不知不觉已
经超过了 10 年，保留了最开始学习 Linux 的点点滴滴，各种嬉戏玩耍，不过，
开始工作一段时间后，这里就都是流水了。

自从搬家到了 ''''GitHub Pages，省心了很多。十年前，用 Wiki 的方式记录并连接
各个页面，用 Emacs 作为工具编写并转换成 HTML 是一个新奇的方式，现在，还
有谁会抱着一个客户端来写博客，有了通用的浏览器，和强大的 JS，Web 可以扮
演所有的东西。

所以当我在 google 里面搜索 emacs-wiki-mode 时，已经搜索不到什么有用的东
西了。也许最开始大家只是使用 emacs 来写 ''''LiveJournal，最后变成了 wiki，最
后大神 maintain 了这个 project，然后变成了 ''''EmacsMuse，然后 muse 成了 GNU
的官方项目，那时候 emacs-wiki-mode 就已经半死不活，有谁还会用一个老项目？

之前 github 上的 emacsmirror 还保留着 emacs-wiki-mode，当时看到这个老项
目，我还是蛮开心的，没想到现在上去翻找，已经搜不到了。

也许我比较古旧吧，还用着这个 mode 写东西，反正也挺趁手的，反正写的也很少，
反正都是流水，反正这个附加挂上去的 emacs-wiki-journal 也是我自己一个人用
而已。

本来还想把自己用的 emacs-wiki-mode 源代码挂到 github 上，现在有点犹豫了。

*** [[CategoryThisSite][CategoryThisSite]] / [[2017-04#p0][Permalink]] 

<!-- date: 2017-04-16T22:42:10+0800 -->

* 17年3月18日 周六 10:43

** Git 二三事

之前公司一直在用 svn，虽然我也有用 github，但并没有真正参与过多人开发的
情况，分布式的 git 在多人开发方面与 svn 有很多不同。

git 是完全并行的开发，意味着提交的时候，origin 远端只是看对应文件能否
merge，不不冲突的话就直接接受了。可是如果我们看版本线，会有这样的情况，
本地刚提交的版本的上一个版本，并不是远端的末端版本，也就是说，在我们这两
次提交的中间，其他人已经有版本提交到远端了。

如果用 source tree 这样的工具看，可以看到本地上个版本对应的远端版本，很
可能有多条线并行出来；先提交的同学，版本线在主线上，后提交的同学，版本线
被并行出来，在最后提交的版本上合并。

svn 呢，因为没有分布式的概念，因此只有一条开发线。

为了更明晰远端库的版本线问题，每次 push 到远端前，需要在本地分支上
rebase origin 分支，其实就是先找到本地跟远端版本的公共父节点，从这个点开
始，将远端的版本合并到本地分支，再将本地分支这个公共父节点版本后的代码，
一个个 apply 上去，之后再 push 到远端，这时候就只有一条线了。

因此，merge 仅仅在末端版本上合并代码，而 rebase 则会找到公共父节点，重整
版本线。

另外一种情况，是本地再多开分支，其中一个分支用来同步远端，这个时候，本地
的另外一个分支，提交的顺序是先提交到本地同步分支，同步分支再 push 到远端。

这个时候，如果要保证三个分支的末端版本一致，同步分支可以先 rebase 远端，
保证末端版本与远端一致，本地分支再 rebase 本地同步分支，本地分支版本线也
与远端一致了；之后，同步分支 merge 本地分支，再 push 到远端。

或者也可以这样，本地同步分支先 merge 本地分支，再 pull rebase 远端，再
push 到远端。不过这个时候，这个用来并行开发的本地分支，版本线跟远端很可
能已经不一样了，这个又要怎么整呢，:)

坑好多呀，因为之前不明白这些，请教了组里面的一位实习生大神，才终于弄懂了。

*** [[CategoryProgramming][CategoryProgramming]] / [[2017-03#p0][Permalink]] 

<!-- date: 2017-03-18T10:43:54+0800 -->

* 17年2月7日 周二 22:18

** ''''AirPods 蓝牙耳机

16 年 12 月中旬定的货，1 月中旬发的货，本来是想买来送人的，后来不了了之，
然后又不想退，索性自己用了吧。

连接佩戴都挺方便的，舒适性上面也还不错，连接了手机、平板，用哪个就连哪个，
唤起 Siri 的没怎么用，觉得鸡肋。声音质量上面，跟有线的差不多，因为多了那
个充电盒子，这个是真方便，不容易丢东西了，然后旅行时也好收纳，续航方面没
长时间用过按下不表。

我用的蓝牙耳机不少了，虽然都是低端货，比如爱国者的 S20，还有魔浪的 U2，
及大康的运动耳机。

其中大康的运动耳机用得最久，跑步用的，效果还行，但跑步时风阻的声音有点大，
用了大概 1 年，就不容易连上了，估计是因为汗水还是其他原因老化了吧，然后
电池也渐渐不够用了，很快就没电，之前都至少能 4 个小时的。

因为这个原因，才有了后面的几款，跟之前大康的不同，不想要专门跑不用的了，
半开放的，半运动的蓝牙耳机就好了（轻微夹耳的，不容易掉）。

魔浪的 U2 仅仅是试用，因为在我的 6sp 上，声音太大，调不低，郁闷的是安卓
机可以调低声音，苹果手机却不可以，跟客服墨迹了很久，他们也搞不定，只好退
了。不过呢，对这个耳机的做工印象不错，连接线很柔软，戴起来也舒服。

爱国者的 S20 用的时间不多，虽然是半开放式，但是耳机有点大，相比魔浪 U2，
能调整声音大小是个极大的优势，但连接线是扁平的，不够柔软，其实我不喜欢，
不过当时很想要一个这样半开放的蓝牙耳机，综合之下这个是最好的了。

可惜 S20 用不长，上班是越来越忙了。

<!-- so, it means i will keep the memories of you, TJJJJ-->

*** [[CategoryLife][CategoryLife]] / [[2017-02#p0][Permalink]] 

<!-- date: 2017-02-07T22:18:18+0800 -->

