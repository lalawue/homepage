#title Welcome
* 14年12月25日 周四 22:16

** ObjC Core Data

Core Data 市面上的文章太多，不管是中文还是英文，所以打算以自己的理解从简
描述。

先从上到下、从大到小理解概念。关键的概念其实只有 4 个：

 - ''''NSManagedModel：数据模型，数据的结构
 - ''''NSManagedModelContext：具体存取增删数据的接口
 - ''''NSPersistentStoreCoordinator：连接 context 与 persistent store 的中间
   件
 - ''''NSPersistentStore：数据库，具体的文件

如果还要简约，那概念上只需要关注 model 跟 store 就可以了，一个是 schema，
模型结构，比如一张表，另一个是数据库，具体到文件。

描述概念间相互关系的图表网上太多，我简略看了一下接口，了解到的是目前 8.1
的 SDK下，一个 context 对应一个 model 和一个 coordinator，一个
coordinator 可以连接多个 store，相互的关系可以脑补了吧。

下面的代码只要建立一个 ''''TestCoreData 的头文件调用一下最下面的 test 就可以
编译跑了，粗看有点多，其实分开函数看就好了，函数名很直白了。

<src type="objc">
@interface UserInfo : NSManagedObject
@property (nonatomic,copy) NSString *name;
@property (nonatomic,copy) NSNumber *uid;
@end

@implementation UserInfo
@dynamic name;
@dynamic uid;
@end

@implementation TestCoreData
- (NSURL*)createStoreDir
{
    NSFileManager *fm = [[NSFileManager alloc] init];
    NSError *error = nil;
    NSURL *durl = [fm URLForDirectory:NSDocumentDirectory
                             inDomain:NSUserDomainMask
                    appropriateForURL:nil
                               create:YES
                                error:&error];
    if (durl == nil) {
        NSLog(@"Fail to create document dir:%@", [error localizedDescription]);
        return nil;
    }
    return durl;
}

- (NSManagedObjectModel*)createModel
{
    NSManagedObjectModel *moModel = [[NSManagedObjectModel alloc] init];
    
    // create the entity
    NSEntityDescription *infoEntity = [[NSEntityDescription alloc] init];
    [infoEntity setName:@"UserInfo"];
    [infoEntity setManagedObjectClassName:@"UserInfo"];
    
    [moModel setEntities:[NSArray arrayWithObject:infoEntity]];
    
    // add the attribute
    NSAttributeDescription *nameAttr = [[NSAttributeDescription alloc] init];
    [nameAttr setName:@"name"];
    [nameAttr setAttributeType:NSStringAttributeType];
    [nameAttr setOptional:NO];
    
    NSAttributeDescription *uidAttr = [[NSAttributeDescription alloc] init];
    [uidAttr setName:@"uid"];
    [uidAttr setAttributeType:NSInteger32AttributeType];
    [uidAttr setOptional:NO];
    
    // set the properties for the entity
    NSArray *ary = [NSArray arrayWithObjects:nameAttr, uidAttr, nil];
    [infoEntity setProperties:ary];
    
    // add localization dictionary
    NSMutableDictionary *localDict = [NSMutableDictionary dictionary];
    [localDict setObject:@"name" forKey:@"Property/name/Entity/UserInfo"];
    [localDict setObject:@"uid" forKey:@"Property/uid/Entity/UserInfo"];
    
    [moModel setLocalizationDictionary:localDict];
    
    return moModel;
}

- (NSManagedObjectContext*)createModelObjectContext:(NSManagedObjectModel*) moModel
{
    NSManagedObjectContext *moMOC = [[NSManagedObjectContext alloc] init];
    NSPersistentStoreCoordinator *co =
           [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:moModel];
    
    [moMOC setPersistentStoreCoordinator:co];
    
    NSString *store_type = NSBinaryStoreType; // NSSQLiteStoreType
    NSString *store_filename = [NSString stringWithFormat:@"storeExample.bin"];
    
    NSError *error = nil;
    NSURL *store_url = [[self createStoreDir]
           URLByAppendingPathComponent:store_filename];
    
    NSLog(@"store url: %@", [store_url absoluteString]);

    NSPersistentStore *pstore = [co addPersistentStoreWithType:store_type
                                                 configuration:nil
                                                           URL:store_url
                                                       options:nil
                                                         error:&error];
    if (pstore == nil) {
        NSLog(@"Fail to create persistence store %@", [error localizedDescription]);
        return nil;
    }
    return moMOC;
}

- (BOOL)test
{
    NSManagedObjectModel *moModel = [self createModel];
    NSManagedObjectContext *moMOC = [self createModelObjectContext:moModel];
    
    NSEntityDescription *infoEntity =
          [[moModel entitiesByName] objectForKey:@"UserInfo"];
    
    // insert
    int i;
    for (i=0; i<10; i++) {
        UserInfo *info = [[UserInfo alloc] initWithEntity:infoEntity
                           insertIntoManagedObjectContext:moMOC];
        info.name = [NSString stringWithFormat:@"n%d", i];
        info.uid = [NSNumber numberWithInt:i];
    }
    
    // save
    NSError *error = nil;
    [moMOC save:&error];
    if (error) {
        NSLog(@"Fail to save: %@", [error localizedDescription]);
        return false;
    }
    
#if 1
    // query & delete
    NSFetchRequest *req = [[NSFetchRequest alloc] init];
    [req setEntity:infoEntity];
    
    NSSortDescriptor *sdesc = 
          [[NSSortDescriptor alloc] initWithKey:@"uid" ascending:YES];
    [req setSortDescriptors:[NSArray arrayWithObject:sdesc]];
    
    NSArray *ary = [moMOC executeFetchRequest:req error:&error];
    if (error && (ary==nil)) {
        NSLog(@"Fail to fetch object: %@", [error localizedDescription]);
        return false;
    }
    for (UserInfo *info in ary) {
        NSLog(@"user info name:%@, uid:%d", info.name, [info.uid intValue]);
        [moMOC deleteObject:info];
    }

    // save again
    [moMOC save:&error];
    if (error) {
        NSLog(@"Fail to save: %@", [error localizedDescription]);
        return false;
    }
#endif
    return true;
}
@end
</src>

更具体细节的东西，比如 Predicates、搜索结果的缓存，可以需要的时候再细查
了，有了重要概念、框架的支撑，往下往细里面走就好办了吧。

明天玩玩新的东西。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p4][Permalink]] 

<!-- date: 2014-12-25T22:16:40+0800 -->

* 14年12月24日 周三 15:29

** NSThread、''''NSRunLoop、GCD、__block

因为想求职 Objective-C 开发的原因，被问到了一些很基础的问题，而我做 iOS
App 已经是一年以前的事情，且也没有那么系统地学习过，所以就慢慢把这些补齐。

我是从 POSIX 的 pthread 入门了解多线程的，用过 mutex 这些临界区保护的方
法，对于 Mac Objective-C 这边的多线程，对应的是 NSThread。

建立多线程是为了同步做一些事情，不影响界面的响应等等，这些事情要么是纯计
算的，要么是各种事件的处理，对于这些事件的检测以及处理，Objective-C 是放
到 ''''NSRunLoop 里面去的，感觉跟满足了 select 以及 epoll 条件下的大括号块差
不多吧。

''''NSRunLoop 就是一个内部循环的结构，一定是从属于某个线程的，要么是属于主线
程，要么是属于自己创建的线程。

下面的例子是建立了一个 ''''NSRunLoop 响应一秒一次的 NSTimer，这个 ''''NSRunLoop
是跑在一个单独的线程（非主线程）里的。

<src type="objc">
- (void)timer_entry:(NSTimer*)t
{
    NSLog(@"timer is main thread %d", [NSThread isMainThread]);
}

static int _newThreadAborted;

- (void)thread_entry:(id)param
{
    NSLog(@"enter thread");
    @autoreleasepool {
        NSTimer *t = [NSTimer timerWithTimeInterval:1
                                              target:self
                                            selector:@selector(timer_entry:)
                                            userInfo:nil
                                             repeats:YES];
        NSRunLoop *r = [NSRunLoop currentRunLoop];
        [r addTimer:t forMode:NSDefaultRunLoopMode];
        while (!_newThreadAborted) {
            [r runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
            NSLog(@"should not reach here until loop ending");
        }
        NSLog(@"thread aborted");
    }
}

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification {
    // Insert code here to initialize your application
    
    NSLog(@"is main thread %d", [NSThread isMainThread]);
    
    NSThread *t = [[NSThread alloc] initWithTarget:self selector:@selector(thread_entry:) object:nil];
    [t start];
}
</src>

上面的例子 ''''NSRunLoop 添加了一个 NSTimer 事件源，同样的可以添加其他的事件
源，比如鼠标、键盘的，这样就可以在某个线程的 ''''NSRunLoop 里面处理具体的事
情了，且不影响主线程。

如果 ''''NSRunLoop 里面 while 了一个死循环，这个线程就做不了其他事情了。如果
这个 ''''NSRunLoop 是在主线程里面，界面就会卡住，一个 NSThread 里面只能有一
个 ''''NSRunLoop，新建立的线程会在调用获取 ''''NSRunLoop 的时候创建。

而 GCD （Grand Central Dispatch） 我觉得中文网络上面的信息挺不错的，也许
也是因为自己之前已经使用了不少了吧，也因为使用的简单，所以当时的项目里面
也让我不需要去关注 NSThread 跟 ''''NSRunLoop 了。

具体的使用其实就是构建一个闭包函数，跟 Lua 里面的闭包效果一样，所以这样
的函数也可以作为值传递了。

比较需要注意的是栈上的闭包函数与堆上的闭包函数的区别，其生命周期是不一样
的。

另外就是闭包内部访问外部的变量值，若是栈上的变量，则是取建立闭包时的值，
若无 __block 修饰，则是建立闭包函数时拷贝到闭包结构里面的值，这个变量在
闭包内部与外部已经没有文法上的联系了，具体表现就是闭包内部修改不影响外面
的变量，外部的修改不影响闭包内部同名的变量。

若加了 __block 修饰，则在文法上面，两者是联系在一起的，闭包内部以及上下
文可以访问到的地方都可以修改，具体的存储地址呢则看闭包是放在栈上还是堆上
了，也就是这个变量实际是跟随闭包的变量。

对了，其实还有全局区的闭包，我觉得只要区别不是栈上的闭包就好了。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p3][Permalink]] 

<!-- date: 2014-12-24T15:29:33+0800 -->

* 14年12月10日 周三 21:47

** OpenGL 3.3 under MacOS (2)

终于查明原因了，并不是 GLFW 不堪用的问题，而是需要在 glGenBuffers 之前，
先跑下面：

<src type="cpp">
    glGenVertexArrays(1, &vaoHandle);
    glBindVertexArray(vaoHandle);
</src>

当然，那些诸如 &#60;Learning Modern 3D Graphics Programming&#62; 的书上面是没有
这两句代码的。

蛋疼呀。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p2][Permalink]] 

<!-- date: 2014-12-10T21:47:14+0800 -->

* 14年12月9日 周二 19:42

** OpenGL 3.3 under MacOS

其实我想说的是在黑苹果下的情况，一般阿婆是只打开 OpenGL 2.1 而已的，用
X11 XQuartz 或者 GLEW，都无法使用 OpenGL 3.3 的，对于我这个初学者来说，
想从 Modern OpenGL 入门，痛苦不堪。

首先，还是先确认黑苹果在硬件上能够支持的 OpenGL API 版本吧，App Store 上
下载 OpenGL Extensions Viewer 来确认硬件情况，比如我的是 ''''GeForce 310，是
能够支持到 OpenGL 3.3 Core 的。

剩下的就是驱动问题了，谷歌得到的结果是建议用新的 GLFW 而不是 GLUT 或者
GLEW 来做，GLFW 在 MacOS 下默认也只打开 OpenGL 2.1 而已，听说要这样才能
打开 3.3 的 Core：

<src type="c">
static void using_opengl_version_330(void) {
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
}
</src>

设置完之后，我就按教程走了，但是，又出现了意外的情况，在我的黑苹果上面，
''''#version 330 的 shader 源码都编译链接过了，但就是没有显示，窗口里面都是
黑的。总之 OpenGL 2.1 可以，3.3 就是不行。即便 glClear 颜色显示 OK，loop
循环也有走。

又不甘心使用 OpenGL 2.1 呢，只好救助于 Apple 原生的系统接口看看了，还好
谷歌查到了不错的东西 [[https://developer.apple.com/library/mac/samplecode/GLEssentials/Introduction/Intro.html][GLEssentials]]，是官方提供的 Objective-C 使用 OpenGL
3.3 API 编程的例子。

立马左上角的 "Download Sample Code"，XCode 打开工程瞬间编译完成，看了一
下接口以及 Shader，确认是使用 OpenGL 3.3 接口无疑，demo 也挺高大上的，果
然官方的东西就是妥妥的。

之前依靠跨平台各种库、以及过时的库起步，加上黑苹果的原因吧，缓慢起步。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p1][Permalink]] 

<!-- date: 2014-12-09T19:42:30+0800 -->

* 14年12月1日 周一 22:53

** 实践了一个 JPEG 解码器

为了更好地了解 JPEG 的解码过程，实践了一个 JPEG 解码器，放到个人 github
上面了，http://github.com/lalawue/jpeg_dec.

参考了不少中英文资料，更多的是中文的，marker 的部分倒是看了 itu-81 的图表。

不需要用 shadowsocks 翻墙技能，仅靠百度到的中文博客歪歪斜斜排版杂乱不堪
的文章，其实也能从无到有实践一个 JPEG 解码器。

也参考了不少 nanojpeg 的代码以及处理流程，最复杂的部分，在我看来是霍夫曼
编码的生成，是自己理解得不好，数据结构课上面的霍夫曼编码部分忘得差不多了。

而 nanojpeg 包括 public domain 的 c++ jpegd 实现的霍夫曼码，其生成我感觉
都不明晰，所以花了不少时间。这个部分倒是中文的某些博客写得很清楚，虽然这
些博客其实也是不知道从哪里抄的（未必是博主第一手资料，且有些还无来源）。

实现了霍夫曼表后，接下来的困难是 IDCT 的部分，看了几个解码库的，包括
libjpeg 的，README 里面写得明明白白：

<pre>
If you think that you know about DCT-based JPEG after reading this book,
then you are in delusion.
</pre>

所以就不琢磨了，说不好都是优化过的代码，调试出来的，不是给人看的，这部分
直接来自 nanojpeg，是一个整型使用位移调整精度的 IDCT 算法，传说的 AA&N
算法，如 libjpeg 里面的，没有看得很明白，其实 jpgd c++ 用的跟 libjpeg 一
样，有用到浮点就是。

然后是一些细节问题，估计看 ITU-81 里面也难看得明白，比如霍夫曼的 VLC 部
分其实我是根据 nanojpeg 的输出比对排错的、IDCT 的部分也是；还有读到
0xffd9 后补齐 bits 的问题，都补 binary 1；以及每个 component 的 dc
restart interval 问题等等。

八卦一下，Mac 下面预览导出的 jpeg 图片，霍夫曼表是一个 DHT segment 带一
个的，PS 则是一个 DHT segment 带多个的。

前人也总结了太多有关 JPEG 结构、解码所需要的知识，这里不重复了，评论下看
到的一些源码吧。

首先目前自己实现的是一个仅支持 Baseline DCT、H1V1 chroma sampling、''''YCbCr
色彩的 JPEG decoder。其实绝大部分的 JPEG 都是 Baseline、H1V1 的，Gray
Scale 其实要比 ''''YCbCr 的简单，再看看后续要不要加上。

nanojpeg 为了实现的简单，资源都全部先申请，包括输出的图片缓冲，亮点是为
了霍夫曼解码的方便，每个霍夫曼表开了个 1^16 条目的数组，将最多 256 个实
际变长码 map 到里面去，这种 LUT 的时间效率没得说了，它自己也介绍说解码时
间上面只比 libjpeg 慢一点点（不支持多线程）。不过空间使用率到了这个地步，
为啥不像下面的解码库一样，对 YUV 转 RGB 也先做 LUT 呢。

而 jpgd c++ 是个 public domain 的解码库，看了一下作者，之前在 Valve 呢，
现在项目合并到了 JPEG encoder 里面去，最后的更新是 2012 年的。其霍夫曼变
长码是将常用的长度小于 8 bits 的 VLC map 到一个 1^8 的空间里面去，剩下的
放到一个 512 大小的空间里面进行二次查询，两个 LUT 加上一个顺序查找的空间
（应该是顺序查找的吧，命名为 tree 的）。

小于 7 bits 的变长码，一次 lookup 就可以定位，超过 7 bits，则需要一个个
bits 来顺序检测并跳转查找了。

jpgd c++ 的最大亮点，在于将 YUV 转 RGB 的部分，做了 LUT。这个空间消耗很
小，比 nanojpeg 丧心病狂的 1^16 LUT 空间少了 N 个数量级，且效率很显著，
特别是当图片变大，像素越来越多的时候。

后续有时间，我也想弄一个稍微改进点的霍夫曼变长码检测方法、以及 YUV 转RGB
的 LUT，目前霍夫曼编码部分是完全按照位数长度从小到大顺序检测的，非常非常
耗时，只是作为一个样例来理解的话，倒还好。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p0][Permalink]] 

<!-- date: 2014-12-01T22:53:41+0800 -->

* 14年5月23日 周五 21:49

** 有关 AOSP

荣耀 3X 的新机出来了，叫做 3X pro，也还是 1698 元，然后上到了 1080p，之
前论坛说的什么 720p 续航优势啊之类的，算是打了自己嘴巴，真的是不能再相信
500 强了。

然后开心的事情是，虽然官方 3X 固件不给力，但是有个移动叔叔论坛的 wasser
大侠修改 MTK 的 AOSP 固件却十分给力，操作速度上来了，然后耗电也还好，那
个重力工具箱十分好用，包括锁屏亮背光当手电筒，调整屏幕亮度，设置物理按键
功能等，相当给力，一点卡顿都没有，真正发挥了八核的威力，且不怎么耗电。

自从我停用了 LT 光感解锁后，一般都能用两天以上了，才发现 LT 是真耗电。

没想到对于我来说，操作省心、省电好用的固件不是官方的，并且对 AOSP 的好感
也慢慢上升。

总之比华为的官方固件好太多，话说自从 3x pro 出来后，很明显对于 3x 的支持，
也会慢慢减弱，比如那个双击亮屏的固件，就一直空缺，3C 有而 3X 没有。

*** [[CategoryLife][CategoryLife]] / [[2014-05#p0][Permalink]] 

<!-- date: 2014-05-23T21:49:45+0800 -->

* 14年4月8日 周二 00:42

** 荣耀 3X 风波

使用华为荣耀 3X 超过一个月了，总体来说这台机子能用，如果是移动、联通双卡
用户（双 3G），且在意手机续航，又要大屏幕的，应该蛮适合。但也得忍受一些
不小的毛病。

屏幕部分黑色色阶显示不好，特别是固件版本 123 以前（具体版本号不记得了），
最近的版本好一些，不晓得是不是也跟分辨率有关，还是说是硬件问题（屏幕硬件
色深不够），总之肯定是远远比不上两年半以前的 4s 的。

外放很渣，声音偏小，最近的固件版本特别是开发版会好一些，论坛上面有推荐
MTK 增大音量的，有作用，但是也有副作用，就是最小音量也提升了，这样晚上听
耳机会没法调小声，我电话比较少，觉得不值得用这个补丁，且这个补丁需要普通
用户 root 手机，表面上需要放弃保修权，而官方没有更好的解决办法，这个套用
广告 500 强是丢华为自己的脸，毕竟 3X 已经推出来有 3 个月了。

我上面说的外放的问题是基于这台手机 1700 元售价说的，如果说 1700 售价都是
这样的外放水平，那我也没话说了。通俗点说，这台手机我不敢放歌曲做铃声，特
别是有人声的歌曲，没法听。

继续黑 3X，后盖很薄，换电池是优点，但是后盖这么薄，手按上去就会卡卡响，
边框扣得也不是很好。我第一台安卓手机 i9000 的运营商定制版 i897，后盖就好
得不得了，我老爸还在用，当然金属后盖，且是推拉扣上、打开的。那台机子就更
早了，应该是 10 年还是 11 年买的。

我也是基于自己认为 1700 元的售价不应该用这么差的后盖，起码厚一点吧，控制
重量也许是需要薄一些，但是现在这个后盖看起来太廉价了，比山寨机还山寨，这
个薄的不是地方。

说完了产品，说说服务本身。

3 月 20 号左右，小米推出了米 note，华为马上推出了 3X 畅玩版，作为一个刚
买 3X 才两周的用户，表示内心觉得被华为卖了。

分几个方面解读，先从 3X 用户的角度说，我自己的例子。我买华为 3X，对比机
型是魅族 MX3，RE 版 1799，当时 HTC 的 M816 还没流出，早知道的话我也许会
选 M816 或者 MX3，前者续航也是考虑，或者屏幕太好，最后考虑的结果华为是大
厂，是国货、民族品牌，且我想要一个中端点的牌子。

可是 3X 畅玩一出来，在我心里面就觉得华为直接宣布同样配置的新手机，今天只
要 998 了，这不是明摆着骗钱吗，手上的货两周跌 700（原价 1700），谁受得了。
而且伤害的是愿意多花点钱买 1700 而不是等待 998 的人，这个价位的手机溢价
更多，不过出货量少也就被华为自己毙了。

从华为的角度出发，则是从一开始就没考虑过保护 3X 用户，3X 畅玩版这个名字，
甚至让我这个 3X 用户觉得，是利用 3X 在荣耀品牌里高配置中端机这个噱头，来
衬托畅玩版本身的性价比，你这个当老用户是提款机呀，当冤大头不是。

这个营销打 -60 分，后来新的广告也印证了这一点，现在叫真八核畅玩版了，营
销太弱了。

这个保护、用心，还体现在其官方论坛上，从时间的维度出发，华为对 3X 用户一
点点的保护都没有，发布前没有打预防针，发布后最开始甚至一度在论坛里面强力
舆论造势 3X 用户脑袋坏了（在其官方论坛内部水军喷的内容看）。

当然发布第二天是个高峰，很多潜水的 3X 用户都受不了（当然夹杂一些水军），
都到论坛发帖质问，估计华为内部水军也开会了，认为强力打压效果不好，然后改
成描述 3X 与 3X 畅玩版的不同，这 700 元差价在哪里，当然没有一句真话。

再往后，估计又开会了，改成安慰为主。

话说人家买 3X 的看到厂家对另外一个也叫 3X 的降价这么快当然心里非常不爽，
对这个品牌马上就认为掉价了，当然我现在也不认为这台手机是中端了，只是当时
用户的心情趋于被欺骗，特别是厂商宣布自己是民族品牌，世界 500 强，这种反
差的感觉就越强烈，加上论坛里面内部水军对质疑用户的强硬反馈，而不是安慰或
疏导，直接在这部分用户的心目中，把这个品牌的形象全砸了。

我也发帖，也看了不少 3X 用户的发帖，都只是想要大公司讨个说法而已，但这个
说法延迟了好几天，一直到现在都没有来，毕竟其实早就没有说法，吞下去的钱难
道还吐出来。

所以不少 3X 用户转成了花黑，而不是花粉，天天上去喷，这是厂商自找的，根本
就不会体会用户的感受。

然后我想说一下，我这段时间被封了 3 个账号，最开始的那个账号被禁言了 7 天，
最近又能登上去了。

另外我还想黑一下那个论坛，表面看起来是官方与用户之间有了沟通的渠道，而现
实呢，只是官方了解用户的一个渠道而已，官方通过这个渠道发布权威的消息，另
外通过这个渠道确定死忠（或者脑残）的用户，然后通过水军、删帖、禁言来控制
舆论导向，虽然在大水面前论坛第一页依然全是黑的。

3X 用户们在论坛上面发布过无数的帖子求这个大屏手机推出双击亮屏的驱动，几
个月过去了，根本没有一点消息，3C 的用户早就享受到了，可是 3X 没有，估计
是用户量太少，驱动不给适配；或者黑一点的说法，是官方要卖自己的唤醒皮套，
才不会推出双击亮屏的驱动呢；说影响续航的可以停一下，因为这个可以做成开关
的，你想用的话自己权衡不就是了。

所以，表面上看起来是用户提出需求，厂家就会想方设法满足，实际上，从来没有
这回事，这个沟通渠道看起来是通的而已，具体功能有什么，该有什么就有什么呗，
关用户什么事呀。

我需要了解你，需要研究你，需要让你保持希望，乐于等待，但是我才不会满足你呢。

而且我有了这个官方的论坛，你那些不大不小的事情，就过来黑吧，让你在失望中
看到一点点的希望，你能怎么样，还能上报纸上新闻不成，等你论点一出来，我就
黑你不安好心，是外部水军，专门黑华为，黑好不容易有了声名的民族品牌，好吧，
删了你的帖再说。

对了，不仅仅是官方论坛这样，百度贴吧里面水军依然是很强势的，貌似脑残也不
少，吧名就叫某某品牌手机吧，但是不准说那个手机的坏消息，这个太搞笑了，维
稳维到贴吧里面来了。

从 3 月 20 号，包括接下来的几天，我想我也认真思考了目前所谓的民族品牌、
世界500 强，我觉得言过其实，产品本身差一些，服务就差更远了，至少从 3X 这
个风波的情况来看。

简单不加思考的解释，是目前这个环境不适合买超过 1000 块的国产手机，只是堆
材料堆性能，材料工艺还不够，高一点价格的手机未必就值那个价钱，从短时间降
价的幅度可以看出来，另外，这个占领价格制高点的风气太盛，因此也少了些因为
精致而值得购买的国产手机，步步高也许算吧，毕竟人家走的是高端路线。

那些走量的手机，就当玩具买吧，好不到哪里去，应该也不会一无是处。

*** [[CategoryLife][CategoryLife]] / [[2014-04#p0][Permalink]] 

<!-- date: 2014-04-08T00:42:37+0800 -->
* 14年3月2日 周日 23:52

** 买了个华为荣耀 3X

水果用得烦了，小屏幕相比之下憋屈，也受够了电量不足，总是提心吊胆各种传感
器注意关闭，状态栏突然间一片转红，再给你嘟一声，静音都没用。于是就想着买
个 2K 以下 5 寸屏续航牛逼的，确实没钱了。

首先考虑的是 MX3，可是续航太渣，贴吧上各种质量贴满天飞，煤粉绝对是真爱呀，
吧里一直置顶回复无数的精华帖是教授如何通过复杂的设置降低电量消耗的，小白
就自觉点不要趟这个坑了。

其实早在 2 年前我玩 I897 时就已经刷机无数次，可是水果惯下来后，就不想这
么折腾了，这也是 I897 玩到后期的心得，真的累了。

我都到魅族实体店摸过无数次 MX3 了，屏幕真心好，边框真心窄，第一眼喜欢、
第二眼还是喜欢，但要小心供着这个让人头疼，或者出个厚底的装个大号电池也不
错呀。

还考虑了 TCL 最近 1999 的 idol x+，第一眼的感觉绝对惊艳，特别是白色， 可
是貌似质量也不怎么样，续航也渣，乐蛙 ROM 也有不少的坑。

3X 也不是太好的选择，但是比较折衷吧，5.5 寸屏貌似过大了，720P 也不算只能
算中等，MTK 8 核是个噱头，但是卖到 1700 的期货价，就不厚道了。可是续航极
好，3K 毫安的电池足够你折腾一天，这个江湖上貌似不多。

当时我还算了一下 PPI，5.5 寸屏 720P，跟 iPad Air 一样是 267 PPI 的，iPad
Air 我是天天用，分辨率感觉很好呀，所以我不是很担心那个分辨率的问题，到手
后发觉也是如此，话说华为 ROM 其实有优化字体等等，分辨率是完全足够。

我摸过 MX3，3X 对比之下，外观其实是老土的，特别是后背，所以我买个了个好
点的背壳，又加厚加重了一点，算是小小弥补。

MX3 屏幕已经被大家各种研究了，3X 的屏幕颜色等等其实不算好，首先不是大猩
猩玻璃，所以自己得贴 9H 的膜，字体显示是可以的，ROM 功能分类设置也不错，
比当年的三星好多了，但我感觉它的调色不对，要么就是这块 IPS 屏幕色域太窄，
总之黑色的深度展现不出来，黑色的地方太浓，分不清层次，图片库里面的sample
图片都是高亮的估计能说明一点问题。从 4s 过来的真是一眼就能看穿。

还有外放的喇叭很渣，我试过插水果的线控耳机，声音很奇怪，不正常，听说是华
为的 3.5mm 音频输出的线序跟水果的不一样，这个我没研究，不懂了。

所以，来电铃声啥的，就别想高大上了，再说外放的音量也很不足。

3X 还有一点让我很不满意的地方，是它的 WIFI 不稳定，不过我也很奇怪不晓得
是不是我的路由器的原因，手头的 4s 是一直都很稳定的，可 iPad Air 也同样有
这个问题，就是状态栏的信号明明是很足的，可是数据却出不去，也收不到，需要
飞行一会儿再重开 wifi 才行。

3X 出货的固件版本是 B123，最新开发版的是 B604，说是解决了 wifi 的问题，
可是却要卡刷，我还没有 micro sd 卡呢，还得买，折腾。

系统的各种省电防护、权限设置，UI 的交互等等，是相当方便且舒服的，这个得
赞一下，Emotion UI 进化到 2.0 了，花粉团也遍布全国了。

开着 WIFI 和移动数据挂了一整天的微信、QQ，发现了个微信的问题，就是省电管
家提示微信 5.2 耗电过高，跟谷歌同步框架一样耗电，可是手机 QQ 却远比他们
少得多。百度上隐隐约约的也提到这个问题，然后换成了微信 5.1，貌似就好了，
不过我还得再跑一整天看看看数据才能下定论。

暂时评价是这样，再跑一两周后看看是不是还有更多的槽要吐。

话说很早之前买的 Noppoo Choc Mini 84，虽然也有点小问题，不过真的习惯了机
械键盘之后，就很不习惯薄膜键盘了，过年在家用的都是薄膜键盘，深刻的体会呀。

*** [[CategoryLife][CategoryLife]] / [[2014-03#p0][Permalink]] 

<!-- date: 2014-03-02T23:52:24+0800 -->

* 14年2月28日 周五 15:08

** 玩了一下 2D 骨骼动画

春节前忙着出了一个只包含战斗场景的 demo，还没有动画部分，那时候这部分还
不熟悉，可没想到年后好懒散，一直弄到现在才把动画部分弄出来了一个样子。

年后也玩到了一些新的卡牌游戏，动画之精美、动作之合理连贯，让我总觉得那些
动画不像是用程序里面调出来的，而是像用动画编辑器做的。

反正我也要研究这部分，索性就大框架都看了一遍。cocos2dx 里面的 actions 就
不说了，那是基础。

不过涉及到人物复杂一点的动作，比如跑动、跳跃、攻击，这些如果用 actions
来调整，那真是头大了，且程序也不用调整那么细的部分。

这些其实是 2D 骨骼动画，之所以不用序列帧，是因为序列帧太费存储空间了。

基于 cocos2dx 的有 spine、dragonbones 以及官方的 cocostuido，其实我觉得
cocostudio 是很浅显易用的，只是导出的数据只能用在 cocos2dx 2.2.2 版本上，
可我是基于 quick-cocos2dx 来做的，这边提供的 CCArmature 版本是 2.1.5 的
呀。

所以播放出来的动画坐标都不对，我花了几个小时将 2.2.2 的 CCArmature 移植
到了 quickx 上，可是动画的前面几帧时间轴不对，总是太快，不晓得是不是新版
本底层的有了更新。

网上搜到了 zrong 修改的 Flash Pro dragonbones 插件，介绍说这部分在 2.1.5
上面效果很好，zrong 本身就经常出没于 quickx 邮件列表，我可是潜水很久了。

之所以一开始不考虑 dragonbones，一方面是担心兼容，另外就是觉得那个方向制
作工具、套件的复杂。 

Flash Pro 确实是大块头，黑苹果本来没装有，我不得不重新下载一个新的，而原
来的 Adobe Extention Manager 还老是闪退，又下了一个新的，然后又花了一个
下午的时间才弄懂 Flash Pro 上面怎么玩动画。

从程序员的眼光来看，感觉相比 cocostudio 的入手难度大多了，不晓得从动画制
作师的角度看如何。

不过这个学习成本到最后发现还是值得的，播放的效果很好，然后缓动也很好，引
擎计算的插值帧也很好，还有骨骼动画确实是要构造骨骼关系才行，否则缓动计算
的骨骼运动路径是不对的。

又学会了一些东西，不过玩归玩，实际上我的游戏估计用不上这么高级的东西，老
老实实玩 actions 就好了。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-02#p0][Permalink]] 

<!-- date: 2014-02-28T15:08:59+0800 -->

* 14年1月16日 周四 12:23

** 设置服务器网络唤醒（WOL）

我的破笔记本往服务器方向又迈了一大步，被我设置成网络唤醒了（Wake On Lan）。
加上之前可以远程关闭的 expect 脚本，现在开关机都不需要手动按电源键，可以
把它放到一个安静的角落里了。

话说 baidu 上搜到的网络唤醒要什么主板支持，要先设置 BIOS 电源管理，我的
例子是不需要的。感觉 WOL 早就是每个主板都必备的功能了吧，即便是被阉割过
的 BIOS，也无法掩盖硬件本身能支持吧。

查了一下破老笔记本的信息，2007 年 11 月买的 HP Presario V3500 的结构，能
看到的 BIOS 管理界面极为简单，根本没有电源管理设置的入口。

在 XP 下设置了网卡接收 Magic Packet 的唤醒方式、电源管理方式，可是 XP 系
统一关闭，网卡的灯也不亮了。当然也无法网络唤醒。

还好有 ubuntu，apt get 一个 ethtool 工具，按照这篇帖子的设置
[[http://ubuntuforums.org/showthread.php?t=234588][HOWTO: Set your system up for Wake On LAN (WOL)]]，然后关闭的时候使用
shutdown -P now 仅仅 poweroff 就好了。

帖子里介绍的内容也挺简单，先 apt-get ethtool，然后往 /etc/init.d 放一个
wakeonlanconfig 开机启动脚本，内容为：

<src tyep="sh">
#!/bin/bash
ethtool -s eth0 wol g
exit
</src>

chmod a+x wakeonlanconfig，然后设置开机启动方式：

<src type="sh">
update-rc.d -f wakeonlanconfig defaults
</src>

这两步手工运行一下，再使用上面的关机命令，可以发现系统关闭了，硬件指示灯
也都不亮了，除了网卡灯和供电部分。

比如我的破本电源连接处、电源键、硬盘、无线以及网卡都有灯，XP 系统的关闭
方式，只剩下电源连接处的灯是亮着的（估计这是一上电就亮，软件无法控制）；
而 ubuntu 下的关机方式，网卡的灯还亮着。

然后网上下一个 WOL 的程序，比如我下的这个 perl 脚本 [[http://gsd.di.uminho.pt/jpo/software/wakeonlan/][Wakeonlan]]，命令行下
运行，后面跟网卡地址就可以唤醒了。

如果发送唤醒命令的主机与被唤醒的主机不在一个子网内，估计要路由做 forward
了，没试过不懂了。

还有，我的破本如果关闭后拔掉电源，网卡不亮了，再接入电源网卡也不亮了，估
计确实是 BIOS 不支持吧，不过只要一直连着电源就没事。

这种远程控制开关机真的很好玩哈哈哈。

*** [[CategoryLinux][CategoryLinux]] / [[2014-01#p4][Permalink]] 

<!-- date: 2014-01-16T12:23:08+0800 -->

* 14年1月11日 周六 14:16

** 苹果折扣日买了个 iPad Air

其实很早就想去 HK 了，要给家里人带奶粉。上一次去 HK 还以为在关口可以买到，
当时奶粉还禁购，然后去澳门也没买，这次可不能忘。

因为还要给基友带 PS4，而 PS4 在 HK 是 12 月 17 号首发，所以 1 月份过来以
为有货，后来终于认识到 PS4 太火爆，整个 HK 都断货。

珠海坐船出发，最早的一班 8:00，70 分钟左右到 HK 中港城，走 5 分钟到天星
小轮，对面就是港岛。船票略贵，去 ￥175，返 HK 210。没几个人过关，回来的
时候也是一样。

到了港岛直奔 IFC 的 Apple Store，早已是里面三圈，外面三圈，好几个苹果员
工在维持队伍秩序。排了大概一个多小时，终于可以进场，看到人家买一个麻袋的，
我只要一个 iPad Air 实在是太不经济了。

本来基友还想要个 iPad 3 smart case 的，可惜都没卖了。iPad Air 折扣到
3.5k 港币，smart cover 也有折扣，就买了个黑色的。全部到手，下单激活不超
过 15 分钟。

剩下的就是给别人带货的时间，买个 Red Wing 的鞋我的鞋都要磨破了，百度地图
不给力，搜索到的店面都是假的，后来只好联系基友谷歌搜索。还好有联通 20 块
50M 的套餐，不至于在 HK 摸黑。

在铜锣湾耗费了整个下午呀，才买到了那双鞋，PS4 断货，着急带上奶粉已经五点
多了，后来发现奶粉买错了，还好后来老妈没认真。然后傻乎乎地回到中港城码头，
还走过头了。结果人家中港城 17:30 后就没有到珠海的了，只有港澳码头才有，
我还从港岛折腾回来坐船，无语。。。哽咽。。。

要不是珠海到 HK 首班是到中港城的，我怎么会犯这种错误。算了，这种误机误车
走冤枉路的事情我已经经历过 N 次了，习惯了。

买到了 21:30 分的船票，然后 KFC 跟着一堆傻逼排队排了 10 分钟，队伍都没动!我
都饿晕了，转身走过了一个 block 那边有家 M 记，没人排队，我才发现在 HK 大
家是有多爱排队！

还好一个汉堡加杯小可只要港币 21，其他真是糟糕透了。

*** [[CategoryLife][CategoryLife]] / [[2014-01#p3][Permalink]] 

<!-- date: 2014-01-11T14:16:39+0800 -->

