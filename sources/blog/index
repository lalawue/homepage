#title Welcome
* 15年1月30日 周五 12:42

** 有关 GLFW

这段时间做的项目是使用 GLFW 来做跨平台的播放器，大体上框架已经好了，音视
频也同步了，大概花了快两周时间，然后也是今天才知道 cocos2dx 3.x 系列是用
glfw 来做 opengl 窗口管理的，我是没有继续深究了，不过因为看到这个，忽然
有种我选得没错的感觉。

GLFW 横跨 Mac/Win/Linux 三个平台，提供基于 OpenGL 渲染窗口，消息机制，这
点很不错，大体上统一了三个平台基础 OpenGL 的创建，销毁，以及鼠标、键盘消
息。

我之前因为想学习 OpenGL，看到的很多国内教程都是 glut 来入门，而且还是
OpenGL 2.x 系列的 API，实际上，现在都已经是 3.x 系列的 API 了，当然系统
总是向下兼容的，老的 API 也能用就是。

若是现在开始涉及到桌面 OpenGL 部分的，强烈推荐呀。

*** [[CategoryProgramming][CategoryProgramming]] / [[2015-01#p2][Permalink]] 

<!-- date: 2015-01-30T12:42:25+0800 -->

* 15年1月15日 周四 01:34

** 获取默认网卡的 IP 地址

目前在做一个简单的服务端程序，需要客户端发现服务端的 IP 地址，然后请求链
接。发现部分是用 UDP 的广播来做了，但是服务端获取 IP 地址部分，遇到了问
题。

服务端里面 TCP bind 时，地址是可以为 INADDR_ANY 的，意味着不管是哪个网络
过来的数据，只要路由到系统，端口对应上，我的服务端程序就可以 accept。看
起来美好，但是流程上走不通，这时候程序其实是不知道 IP 包是从哪个网卡过来
的，所以即便接收到了客户端的 UDP 广播请求，也仍然无法发送可以连接的 IP
地址给客户端，因为从系统里面获取地址的 getsockname() 获取的其实是之前
bind 的地址，也就是 &#34;0.0.0.0&#34;。

路由都已经通了，但却无法获取路由过的网卡 IP 地址。如果这一切都只能通过之
前的 bind 来显式地指定只接收某个网络过来的包，确实是太折腾了。

简单点，不如就是用系统默认网卡的 IP 地址好了，至少系统保证这个是最为可用
的地址。

MacOS 下获取系统网络设备名称以及地址跟 Linux 下的相似，都是 getifaddrs()，
搜到了一篇中文介绍；然后获取系统默认网卡的信息，我是从 stackoverflow 上
面搜到的。

 - [[http://www.cnblogs.com/sammei/p/3955679.html][getifaddrs]]
 - [[http://stackoverflow.com/questions/4872196/how-to-get-the-wifi-gateway-address-on-the-iphone][How to get the WIFI gateway address on the iPhone?]]

这样，bind 的时候仍然可以为 INADDR_ANY，客户端 UDP 广播请求的时候，服务
端大方发送可连接的 IP 地址。扯远点，复杂点的情况，多个网卡，多个异构网络，
服务端可以根据具体的请求发送不同的 IP 地址，只要能路由过来，都可以
accept。

大概就是这个意思了吧。

*** [[CategoryProgramming][CategoryProgramming]] / [[2015-01#p1][Permalink]] 

<!-- date: 2015-01-15T01:34:41+0800 -->

* 15年1月3日 周六 11:19

** HTTP Downloader

忙了两天多那个 [[https://github.com/lalawue/http_downloader][HTTP Downloader]]，原来只是想实现一个 keep-alive 的连接的
socket，当时也想到这个东西不会简单，因为一方面底层的是 low level 的
socket，另外一方面呢，需要处理一层 http 协议，还有一个 dns。

后来是因为找到了 dns 的代码，就开工了，才发现复杂呀，一方面 c 的部分我觉
得我大意了，编码不够小心，各种折腾。

另外就是 c 的 string 库太不好用了，所以不得不封装了一个，至少得有 split
这个函数吧，没有的话啥都不用玩了。

其实大概一天不到基本的 http get 已经完成了，只是代码太糟糕，我觉得需要改
进一下，最主要的就是 string 库，于是昨天折腾了快一天呀，代码清晰了很多。

这个 string 库是有 gc 的，从 head 操作产生的其他 object，都会随着 head
的 destroy 而 destory。新建 head 的 interface 就那么几个，很有限，所以其
实可以在开始复杂操作时新建 head，之后后清除掉那个入口的 head。

新建 head 的接口除了 malloc 一段 cstring，还可以 map 一段 cstring 地址给
它作为操作的空间，这时候内部标记 clone，就是这个 mstring 的 cstr 地址不
是自己保存的，之后的 destroy 不用释放这个空间，对于像 http head 或者
body 的分析时，这个就很有用了。

由于新建 mstring 的空间其实是堆上的，对于各种小操作时产生的 mstring，不
大好，还不如 cloudwu 那个栈上的方式，栈上的方式新建轻松，而且没有碎片的
产生。

不过呢，就是得随时注意，这些栈上的对象何时销毁，需要的时候需要转成堆上的
对象。

我有个想法，其实这些小碎片，不如申请一个专用的堆来操作，比如这个堆绑定在
head 的 allocator 上，从 head 产生的所有 object 都是用这个 allocator，这
样就避免了大量的小对象，对于内存碎片的控制是有益的，特别是对于那种 map
cstring 过来的对象，因为本身 cstring 空间是不用释放的，这时候就很有用了，
因为 mstring 自己控制用的结构，空间占用不大。

不过呢，新建的 heap 多大才有用而又不至于浪费，那就又是另外一回事了，以及
这个接口如何提供的问题，这个想法还得斟酌一下。

*** [[CategoryProgramming][CategoryProgramming]] / [[2015-01#p0][Permalink]] 

<!-- date: 2015-01-03T11:19:57+0800 -->

* 14年12月29日 周一 10:22

** My First Mac App - ''''TcBrowserMac

开始练习 Mac App 的编写，与 iOS App 有许多不同，昨天花了一天时间，山寨了
一个 ''''TcBrowser，一个筛选算法题目的小软件，作者博客页面
[[http://zh.lucida.me/blog/top-code-offline-browser/][Top Coder算法题目浏览器]]。

也许是我没有深入开发的原因，感觉不再像 iOS 一样，需要多个 View
Controller 了，使得我一开始就考虑模块划分的问题，虽然这个软件是个小工具
而已。

然后考虑像 win 一样，可以在文件夹下面打开访问当前文件夹的目录，由于 Mac
是打包成 bundle 来跑的，界面上的 app 其实是个文件夹，所以我之前整的方法
都不对，需要通过 [[NSBundle mainBundle] bundlePath] 来获取。

然后 ''''StoryBoard 方面，由于软件是个窗口，所以大小是可变的，一开始就得考虑
自动布局的问题，Apple 文档那边对于自动布局长篇大论不说，还有一个用于自动
布局的 DSL，足够复杂了，昨天时间有限，我是没有看透。

实际是用 ''''StoryBoard 点击 nib 后 Editor -> Resolve Auto Layout Issues 上
面的 Add Missing Constraints 来做的，每添加一个控件，就要 Add 一次。

然后感觉还跟控件添加的顺序有关系，Xcode 会猜测这个控件到底是对齐那一边，
依据的是 superview 还是哪个 view，这些 constraints 在 inspector 里面几乎
不能配置，我本来一个 webview 靠右是要左对齐的，然后右边让它跟着
superview 无限扩展，可是如果给弄成右对齐就改不了了，反正我是没弄懂怎么改，
所以我只好把 constraints 删除又添加一遍。

然后是 tableview，与 iOS 也有些不同，没有了 cell 的概念，取而代之的是
NSView，没有了 index，而是一个 ''''NSTableColumn 的结构，table column 的
identifier 可以设置，重用时也是依据这些 identifier。不过 column 的
header title 我折腾了不少时间，然后是宽度也是通过 column 设置的。

跟 iOS 一样，只需要设置两个函数就可以让数据上来了，一个是
numberOfRowsInTableView，一个是 viewForTableColumn。

最后是软件图标的问题，感觉与 iOS 也不一样，也许是我之前没有那么正规军的
原因。我是想要 Dock 上面自定义图标，谷歌到的方法也只是动态设置的而已，关
闭的时候很明显会显示回默认的那个。

实际上呢，需要设置的方法在 [[https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Optimizing/Optimizing.html#//apple_ref/doc/uid/TP40012302-CH7-SW3][Apple Doc - Optimizing for High Resolution]]，
具体是需要下面几个大小的图标，然后放到 icon_name.iconset 这个文件夹下面

<example>
icon_16x16.png
icon_16x16@2x.png
icon_32x32.png
icon_32x32@2x.png
icon_128x128.png
icon_128x128@2x.png
icon_256x256.png
icon_256x256@2x.png
icon_512x512.png
icon_512x512@2x.png
</example>

终端下使用命令

<src type="sh">
$ iconutil -c icns icon_name.iconset
</src>

 来生成，然后拖到工程文件里面就好了，默认就是那个图标了，这个也折腾了不
 少时间 ，第一个 Mac App 终于完成了，地址在这里 [[http://pan.baidu.com/s/1sjv3gNN][TcBrowserMac]]，密码是宇宙终极答案。



*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p6][Permalink]] 

<!-- date: 2014-12-29T10:22:03+0800 -->

* 14年12月27日 周六 17:58

** ObjC Animation

其实去年在做那个 App 的时候就有使用过简单的动画，接口是 UIView 的
animateWithDuration，只是平移了一下 view。

今天学到的 iOS 的动画，分成几个部分，分别是针对 view 的，针对 controller
的过渡动画，还有就是自由度很高的交互动画，交互动画其实可以看成是最简单的
游戏了。

针对 view 的动画除了我之前用的 animateWithDuration 方法，其实 view 的很
多属性都是可以更改数值然后交给系统去实现动作的，只需要创建 animation 设
置动画属性，然后使用 view 的 layer 实体 addAnimation 就好。

view 中的 layer 需要说一下，为了实现动画，有多个副本，一个是表示最终状态
的（model layer），一个是表示的是当前的（presentation layer），
presentation 是专门用来显示动画的，结束后就被设成了 model 的状态。

后面例子的还用画图实现了一个动画，画图部分就纯是 CPU 来计算了。另外一个
部分是 controller 的转场动画，例子比我之前的平移复杂了一些，用了系统给出
的 delegate 接口来设置，总之这也是可以自定义的。

还有最后的可交互动画，实际上就跟游戏没啥区别了，动画部分的数值需要不断根
据用户的交互来获取、计算，然后设置具体的显示，这些计算实际上是在显示驱动
的每一帧间隔里面做的。

cocos2dx 的底层部分也是通过 display link 来驱动实现每一帧的画图与计算，
然后用户的输入是通过 UIView 的 ''''UIKeyInput delegate 来做的，而不像这个例
子通过手势控件 recognizer 来做的， cocos2dx 的方式更灵活一些，不过两者对
于动画显示、操作最底层的部分是相似的。

没想到两者后底层部分的驱动结构其实是一样的，display link 与 run loop。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p5][Permalink]] 

<!-- date: 2014-12-27T17:58:25+0800 -->

* 14年12月25日 周四 22:16

** ObjC Core Data

Core Data 市面上的文章太多，不管是中文还是英文，所以打算以自己的理解从简
描述。

先从上到下、从大到小理解概念。关键的概念其实只有 4 个：

 - ''''NSManagedModel：数据模型，数据的结构
 - ''''NSManagedModelContext：具体存取增删数据的接口
 - ''''NSPersistentStoreCoordinator：连接 context 与 persistent store 的中间
   件
 - ''''NSPersistentStore：数据库，具体的文件

如果还要简约，那概念上只需要关注 model 跟 store 就可以了，一个是 schema，
模型结构，比如一张表，另一个是数据库，具体到文件。

描述概念间相互关系的图表网上太多，我简略看了一下接口，了解到的是目前 8.1
的 SDK下，一个 context 对应一个 model 和一个 coordinator，一个
coordinator 可以连接多个 store，相互的关系可以脑补了吧。

下面的代码只要建立一个 ''''TestCoreData 的头文件调用一下最下面的 test 就可以
编译跑了，粗看有点多，其实分开函数看就好了，函数名很直白了。

<src type="objc">
@interface UserInfo : NSManagedObject
@property (nonatomic,copy) NSString *name;
@property (nonatomic,copy) NSNumber *uid;
@end

@implementation UserInfo
@dynamic name;
@dynamic uid;
@end

@implementation TestCoreData
- (NSURL*)createStoreDir
{
    NSFileManager *fm = [[NSFileManager alloc] init];
    NSError *error = nil;
    NSURL *durl = [fm URLForDirectory:NSDocumentDirectory
                             inDomain:NSUserDomainMask
                    appropriateForURL:nil
                               create:YES
                                error:&error];
    if (durl == nil) {
        NSLog(@"Fail to create document dir:%@", [error localizedDescription]);
        return nil;
    }
    return durl;
}

- (NSManagedObjectModel*)createModel
{
    NSManagedObjectModel *moModel = [[NSManagedObjectModel alloc] init];
    
    // create the entity
    NSEntityDescription *infoEntity = [[NSEntityDescription alloc] init];
    [infoEntity setName:@"UserInfo"];
    [infoEntity setManagedObjectClassName:@"UserInfo"];
    
    [moModel setEntities:[NSArray arrayWithObject:infoEntity]];
    
    // add the attribute
    NSAttributeDescription *nameAttr = [[NSAttributeDescription alloc] init];
    [nameAttr setName:@"name"];
    [nameAttr setAttributeType:NSStringAttributeType];
    [nameAttr setOptional:NO];
    
    NSAttributeDescription *uidAttr = [[NSAttributeDescription alloc] init];
    [uidAttr setName:@"uid"];
    [uidAttr setAttributeType:NSInteger32AttributeType];
    [uidAttr setOptional:NO];
    
    // set the properties for the entity
    NSArray *ary = [NSArray arrayWithObjects:nameAttr, uidAttr, nil];
    [infoEntity setProperties:ary];
    
    // add localization dictionary
    NSMutableDictionary *localDict = [NSMutableDictionary dictionary];
    [localDict setObject:@"name" forKey:@"Property/name/Entity/UserInfo"];
    [localDict setObject:@"uid" forKey:@"Property/uid/Entity/UserInfo"];
    
    [moModel setLocalizationDictionary:localDict];
    
    return moModel;
}

- (NSManagedObjectContext*)createModelObjectContext:(NSManagedObjectModel*) moModel
{
    NSManagedObjectContext *moMOC = [[NSManagedObjectContext alloc] init];
    NSPersistentStoreCoordinator *co =
           [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:moModel];
    
    [moMOC setPersistentStoreCoordinator:co];
    
    NSString *store_type = NSBinaryStoreType; // NSSQLiteStoreType
    NSString *store_filename = [NSString stringWithFormat:@"storeExample.bin"];
    
    NSError *error = nil;
    NSURL *store_url = [[self createStoreDir]
           URLByAppendingPathComponent:store_filename];
    
    NSLog(@"store url: %@", [store_url absoluteString]);

    NSPersistentStore *pstore = [co addPersistentStoreWithType:store_type
                                                 configuration:nil
                                                           URL:store_url
                                                       options:nil
                                                         error:&error];
    if (pstore == nil) {
        NSLog(@"Fail to create persistence store %@", [error localizedDescription]);
        return nil;
    }
    return moMOC;
}

- (BOOL)test
{
    NSManagedObjectModel *moModel = [self createModel];
    NSManagedObjectContext *moMOC = [self createModelObjectContext:moModel];
    
    NSEntityDescription *infoEntity =
          [[moModel entitiesByName] objectForKey:@"UserInfo"];
    
    // insert
    int i;
    for (i=0; i<10; i++) {
        UserInfo *info = [[UserInfo alloc] initWithEntity:infoEntity
                           insertIntoManagedObjectContext:moMOC];
        info.name = [NSString stringWithFormat:@"n%d", i];
        info.uid = [NSNumber numberWithInt:i];
    }
    
    // save
    NSError *error = nil;
    [moMOC save:&error];
    if (error) {
        NSLog(@"Fail to save: %@", [error localizedDescription]);
        return false;
    }
    
#if 1
    // query & delete
    NSFetchRequest *req = [[NSFetchRequest alloc] init];
    [req setEntity:infoEntity];
    
    NSSortDescriptor *sdesc = 
          [[NSSortDescriptor alloc] initWithKey:@"uid" ascending:YES];
    [req setSortDescriptors:[NSArray arrayWithObject:sdesc]];
    
    NSArray *ary = [moMOC executeFetchRequest:req error:&error];
    if (error && (ary==nil)) {
        NSLog(@"Fail to fetch object: %@", [error localizedDescription]);
        return false;
    }
    for (UserInfo *info in ary) {
        NSLog(@"user info name:%@, uid:%d", info.name, [info.uid intValue]);
        [moMOC deleteObject:info];
    }

    // save again
    [moMOC save:&error];
    if (error) {
        NSLog(@"Fail to save: %@", [error localizedDescription]);
        return false;
    }
#endif
    return true;
}
@end
</src>

更具体细节的东西，比如 Predicates、搜索结果的缓存，可以需要的时候再细查
了，有了重要概念、框架的支撑，往下往细里面走就好办了吧。

明天玩玩新的东西。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p4][Permalink]] 

<!-- date: 2014-12-25T22:16:40+0800 -->

* 14年12月24日 周三 15:29

** NSThread、''''NSRunLoop、GCD、__block

因为想求职 Objective-C 开发的原因，被问到了一些很基础的问题，而我做 iOS
App 已经是一年以前的事情，且也没有那么系统地学习过，所以就慢慢把这些补齐。

我是从 POSIX 的 pthread 入门了解多线程的，用过 mutex 这些临界区保护的方
法，对于 Mac Objective-C 这边的多线程，对应的是 NSThread。

建立多线程是为了同步做一些事情，不影响界面的响应等等，这些事情要么是纯计
算的，要么是各种事件的处理，对于这些事件的检测以及处理，Objective-C 是放
到 ''''NSRunLoop 里面去的，感觉跟满足了 select 以及 epoll 条件下的大括号块差
不多吧。

''''NSRunLoop 就是一个内部循环的结构，一定是从属于某个线程的，要么是属于主线
程，要么是属于自己创建的线程。

下面的例子是建立了一个 ''''NSRunLoop 响应一秒一次的 NSTimer，这个 ''''NSRunLoop
是跑在一个单独的线程（非主线程）里的。

<src type="objc">
- (void)timer_entry:(NSTimer*)t
{
    NSLog(@"timer is main thread %d", [NSThread isMainThread]);
}

static int _newThreadAborted;

- (void)thread_entry:(id)param
{
    NSLog(@"enter thread");
    @autoreleasepool {
        NSTimer *t = [NSTimer timerWithTimeInterval:1
                                              target:self
                                            selector:@selector(timer_entry:)
                                            userInfo:nil
                                             repeats:YES];
        NSRunLoop *r = [NSRunLoop currentRunLoop];
        [r addTimer:t forMode:NSDefaultRunLoopMode];
        while (!_newThreadAborted) {
            [r runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
            NSLog(@"should not reach here until loop ending");
        }
        NSLog(@"thread aborted");
    }
}

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification {
    // Insert code here to initialize your application
    
    NSLog(@"is main thread %d", [NSThread isMainThread]);
    
    NSThread *t = [[NSThread alloc] initWithTarget:self selector:@selector(thread_entry:) object:nil];
    [t start];
}
</src>

上面的例子 ''''NSRunLoop 添加了一个 NSTimer 事件源，同样的可以添加其他的事件
源，比如鼠标、键盘的，这样就可以在某个线程的 ''''NSRunLoop 里面处理具体的事
情了，且不影响主线程。

如果 ''''NSRunLoop 里面 while 了一个死循环，这个线程就做不了其他事情了。如果
这个 ''''NSRunLoop 是在主线程里面，界面就会卡住，一个 NSThread 里面只能有一
个 ''''NSRunLoop，新建立的线程会在调用获取 ''''NSRunLoop 的时候创建。

而 GCD （Grand Central Dispatch） 我觉得中文网络上面的信息挺不错的，也许
也是因为自己之前已经使用了不少了吧，也因为使用的简单，所以当时的项目里面
也让我不需要去关注 NSThread 跟 ''''NSRunLoop 了。

具体的使用其实就是构建一个闭包函数，跟 Lua 里面的闭包效果一样，所以这样
的函数也可以作为值传递了。

比较需要注意的是栈上的闭包函数与堆上的闭包函数的区别，其生命周期是不一样
的。

另外就是闭包内部访问外部的变量值，若是栈上的变量，则是取建立闭包时的值，
若无 __block 修饰，则是建立闭包函数时拷贝到闭包结构里面的值，这个变量在
闭包内部与外部已经没有文法上的联系了，具体表现就是闭包内部修改不影响外面
的变量，外部的修改不影响闭包内部同名的变量。

若加了 __block 修饰，则在文法上面，两者是联系在一起的，闭包内部以及上下
文可以访问到的地方都可以修改，具体的存储地址呢则看闭包是放在栈上还是堆上
了，也就是这个变量实际是跟随闭包的变量。

对了，其实还有全局区的闭包，我觉得只要区别不是栈上的闭包就好了。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p3][Permalink]] 

<!-- date: 2014-12-24T15:29:33+0800 -->

* 14年12月10日 周三 21:47

** OpenGL 3.3 under MacOS (2)

终于查明原因了，并不是 GLFW 不堪用的问题，而是需要在 glGenBuffers 之前，
先跑下面：

<src type="cpp">
    glGenVertexArrays(1, &vaoHandle);
    glBindVertexArray(vaoHandle);
</src>

当然，那些诸如 &#60;Learning Modern 3D Graphics Programming&#62; 的书上面是没有
这两句代码的。

蛋疼呀。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p2][Permalink]] 

<!-- date: 2014-12-10T21:47:14+0800 -->

* 14年12月9日 周二 19:42

** OpenGL 3.3 under MacOS

其实我想说的是在黑苹果下的情况，一般阿婆是只打开 OpenGL 2.1 而已的，用
X11 XQuartz 或者 GLEW，都无法使用 OpenGL 3.3 的，对于我这个初学者来说，
想从 Modern OpenGL 入门，痛苦不堪。

首先，还是先确认黑苹果在硬件上能够支持的 OpenGL API 版本吧，App Store 上
下载 OpenGL Extensions Viewer 来确认硬件情况，比如我的是 ''''GeForce 310，是
能够支持到 OpenGL 3.3 Core 的。

剩下的就是驱动问题了，谷歌得到的结果是建议用新的 GLFW 而不是 GLUT 或者
GLEW 来做，GLFW 在 MacOS 下默认也只打开 OpenGL 2.1 而已，听说要这样才能
打开 3.3 的 Core：

<src type="c">
static void using_opengl_version_330(void) {
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
}
</src>

设置完之后，我就按教程走了，但是，又出现了意外的情况，在我的黑苹果上面，
''''#version 330 的 shader 源码都编译链接过了，但就是没有显示，窗口里面都是
黑的。总之 OpenGL 2.1 可以，3.3 就是不行。即便 glClear 颜色显示 OK，loop
循环也有走。

又不甘心使用 OpenGL 2.1 呢，只好救助于 Apple 原生的系统接口看看了，还好
谷歌查到了不错的东西 [[https://developer.apple.com/library/mac/samplecode/GLEssentials/Introduction/Intro.html][GLEssentials]]，是官方提供的 Objective-C 使用 OpenGL
3.3 API 编程的例子。

立马左上角的 "Download Sample Code"，XCode 打开工程瞬间编译完成，看了一
下接口以及 Shader，确认是使用 OpenGL 3.3 接口无疑，demo 也挺高大上的，果
然官方的东西就是妥妥的。

之前依靠跨平台各种库、以及过时的库起步，加上黑苹果的原因吧，缓慢起步。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p1][Permalink]] 

<!-- date: 2014-12-09T19:42:30+0800 -->

* 14年12月1日 周一 22:53

** 实践了一个 JPEG 解码器

为了更好地了解 JPEG 的解码过程，实践了一个 JPEG 解码器，放到个人 github
上面了，http://github.com/lalawue/jpeg_dec.

参考了不少中英文资料，更多的是中文的，marker 的部分倒是看了 itu-81 的图表。

不需要用 shadowsocks 翻墙技能，仅靠百度到的中文博客歪歪斜斜排版杂乱不堪
的文章，其实也能从无到有实践一个 JPEG 解码器。

也参考了不少 nanojpeg 的代码以及处理流程，最复杂的部分，在我看来是霍夫曼
编码的生成，是自己理解得不好，数据结构课上面的霍夫曼编码部分忘得差不多了。

而 nanojpeg 包括 public domain 的 c++ jpegd 实现的霍夫曼码，其生成我感觉
都不明晰，所以花了不少时间。这个部分倒是中文的某些博客写得很清楚，虽然这
些博客其实也是不知道从哪里抄的（未必是博主第一手资料，且有些还无来源）。

实现了霍夫曼表后，接下来的困难是 IDCT 的部分，看了几个解码库的，包括
libjpeg 的，README 里面写得明明白白：

<pre>
If you think that you know about DCT-based JPEG after reading this book,
then you are in delusion.
</pre>

所以就不琢磨了，说不好都是优化过的代码，调试出来的，不是给人看的，这部分
直接来自 nanojpeg，是一个整型使用位移调整精度的 IDCT 算法，传说的 AA&N
算法，如 libjpeg 里面的，没有看得很明白，其实 jpgd c++ 用的跟 libjpeg 一
样，有用到浮点就是。

然后是一些细节问题，估计看 ITU-81 里面也难看得明白，比如霍夫曼的 VLC 部
分其实我是根据 nanojpeg 的输出比对排错的、IDCT 的部分也是；还有读到
0xffd9 后补齐 bits 的问题，都补 binary 1；以及每个 component 的 dc
restart interval 问题等等。

八卦一下，Mac 下面预览导出的 jpeg 图片，霍夫曼表是一个 DHT segment 带一
个的，PS 则是一个 DHT segment 带多个的。

前人也总结了太多有关 JPEG 结构、解码所需要的知识，这里不重复了，评论下看
到的一些源码吧。

首先目前自己实现的是一个仅支持 Baseline DCT、H1V1 chroma sampling、''''YCbCr
色彩的 JPEG decoder。其实绝大部分的 JPEG 都是 Baseline、H1V1 的，Gray
Scale 其实要比 ''''YCbCr 的简单，再看看后续要不要加上。

nanojpeg 为了实现的简单，资源都全部先申请，包括输出的图片缓冲，亮点是为
了霍夫曼解码的方便，每个霍夫曼表开了个 1^16 条目的数组，将最多 256 个实
际变长码 map 到里面去，这种 LUT 的时间效率没得说了，它自己也介绍说解码时
间上面只比 libjpeg 慢一点点（不支持多线程）。不过空间使用率到了这个地步，
为啥不像下面的解码库一样，对 YUV 转 RGB 也先做 LUT 呢。

而 jpgd c++ 是个 public domain 的解码库，看了一下作者，之前在 Valve 呢，
现在项目合并到了 JPEG encoder 里面去，最后的更新是 2012 年的。其霍夫曼变
长码是将常用的长度小于 8 bits 的 VLC map 到一个 1^8 的空间里面去，剩下的
放到一个 512 大小的空间里面进行二次查询，两个 LUT 加上一个顺序查找的空间
（应该是顺序查找的吧，命名为 tree 的）。

小于 7 bits 的变长码，一次 lookup 就可以定位，超过 7 bits，则需要一个个
bits 来顺序检测并跳转查找了。

jpgd c++ 的最大亮点，在于将 YUV 转 RGB 的部分，做了 LUT。这个空间消耗很
小，比 nanojpeg 丧心病狂的 1^16 LUT 空间少了 N 个数量级，且效率很显著，
特别是当图片变大，像素越来越多的时候。

后续有时间，我也想弄一个稍微改进点的霍夫曼变长码检测方法、以及 YUV 转RGB
的 LUT，目前霍夫曼编码部分是完全按照位数长度从小到大顺序检测的，非常非常
耗时，只是作为一个样例来理解的话，倒还好。

*** [[CategoryProgramming][CategoryProgramming]] / [[2014-12#p0][Permalink]]

<!-- date: 2014-12-01T22:53:41+0800 -->

* 14年5月23日 周五 21:49

** 有关 AOSP

荣耀 3X 的新机出来了，叫做 3X pro，也还是 1698 元，然后上到了 1080p，之
前论坛说的什么 720p 续航优势啊之类的，算是打了自己嘴巴，真的是不能再相信
500 强了。

然后开心的事情是，虽然官方 3X 固件不给力，但是有个移动叔叔论坛的 wasser
大侠修改 MTK 的 AOSP 固件却十分给力，操作速度上来了，然后耗电也还好，那
个重力工具箱十分好用，包括锁屏亮背光当手电筒，调整屏幕亮度，设置物理按键
功能等，相当给力，一点卡顿都没有，真正发挥了八核的威力，且不怎么耗电。

自从我停用了 LT 光感解锁后，一般都能用两天以上了，才发现 LT 是真耗电。

没想到对于我来说，操作省心、省电好用的固件不是官方的，并且对 AOSP 的好感
也慢慢上升。

总之比华为的官方固件好太多，话说自从 3x pro 出来后，很明显对于 3x 的支持，
也会慢慢减弱，比如那个双击亮屏的固件，就一直空缺，3C 有而 3X 没有。

*** [[CategoryLife][CategoryLife]] / [[2014-05#p0][Permalink]] 

<!-- date: 2014-05-23T21:49:45+0800 -->

