#title Archive for October, 2024

#p0
#date 24年10月12日 周六 16:19

## WebSocket（2）

之前版本的 cincau 是一个 MVC 模式的 HTTP server，内部认为一个业务逻辑单元（controller、或 page）可以匹配多个 URL 数据请求，一次 URL 请求将抽象为一个 request 实例给 controller 处理，controller 将 response 对应的 HTML，而 model 层则是 SVR 内部数据源的抽象。

所以 cincau 的 request 是一次 HTTP URL 请求的数据集合，比如请求的 method、path，header key/value 数据。

但后续 cincau 将支持 WebSocket，本来 WS 也是 HTTP upgrade 而来，只是 WS 是长连接，在 cincau 内部，希望继续复用已有的 MVC 模式，复用之前的 request 结构，并且，WS 和 HTTP 共用一个端口号。

大体上没什么问题的，在框架设计上，可以特例 HTTP 为仅有一帧的 frame，并指定专用的 frame type，而 WS 可能一次带有多帧，区分 PING、PONG、TXT、BINARY 的 frame type。

但作为长连接的 WS，跟 HTTP 的最大的不同，在于

- 从 SVR 看来，CNT 有从未链接到已链接，以及从已链接到断开连接，这两种状态的变化
- controller 需要 SVR 提供主动触发给 CNT push 数据的函数入口（目前通过定时的回调来给业务层作为触发入口）

以上两点，都将复用提供 request 给 controller 的函数（参数不变，但不同状态下 request 带有不同的标记），比如使用 isPeer() 区分是 CNT 请求过来的，还是 SVR 主动触发的，以及使用 isDisconnect() 来区分 CNT 是已建立链接，还是掉线了（可能是 CNT 的 TCP 主动断开，或者 SVR PING 后一定时间内未收到 PONG 回应，SVR 主动 close 了 TCP 导致）。

大概是上面这样的想法，感觉应该可行。

然后在 [cincau](https://github.com/lalawue/cincau) 增加了 WebSocket 的相关 demo，实现了一个简陋的聊天室。

#category Programming
