#title Archive for October, 2020

#p1
#date 20年10月21日 周三 20:51

## ffi_gccload 在 Lua 中动态加载 C Source

不晓得从哪里搜到了这个库 [lua-tcc](https://github.com/javierguerragiraldez/lua-tcc)，可以在 Lua 运行期间，通过 one pass 的 TCC 动态加载 C 代码，让 Lua 的控制可以更深入底层，甚至可以在 Lua 中进行 C 的编程。

可惜这个项目距离久远，TCC 在 MacOS 下面编译也成问题，意味着通用性欠佳，挺可惜的。不过有了这个想法后，想着不通过 TCC，用 GCC、Clang 其实也可以的嘛，于是就有了 [ffi_gccload](https://github.com/lalawue/ffi_gccload)。

流程变成了这样，将 C Source String 导入到一个源文件里面，通过 GCC 编译得到动态库，使用 ffi.load() 加载进来，并通过 ffi.cdef 声明接口，就可以使用了。

其实就是将 C 的编译、链接过程给固定了就好，如下的代码：

```source
local config = require("ffi_gccload").new()

-- like ffi.cdef
config:addSourceDef([[
    int print_name(void);
    int add_num(int a, int b); 
]])
local p = config:loadSourceString([[
#include <stdio.h>
int print_name(void) {
    printf("Hello, world\n");
    return 0;
}
int add_num(int a, int b) {
    return a * 2 + b;
}
]])
if p then
    p.print_name()
    local a, b = ...
    a, b = a and tonumber(a) or 0, b and tonumber(b) or 0
    print("result", p.add_num(a, b))
else
    print("failed to load")
end
```

生成一个动态编译配置，会输出

```source
$ lua test.lua 2 3
Hello, world
result  7
```

其实是将编译产生的中间 .so 放在临时目录，加载后其实就可以删除掉这个 so 了，这在 MacOS 以及 Linux 应该都是可以的。

上面生成的动态编译配置，其实可以加入 include、libary 的 path 以及 lib name，已经越来越像一个 build 系统了，其实就是类似的。

有了上面这套，虽然相比 TCC 速度慢一点（毕竟 TCC 是 one pass 就出成果的），但是胜在兼容性号，修改一下后，估计 Windows 下面也是能跑的。

往后可以在服务端拿到 C 代码，捣鼓以下就能用到客户端上面了，或者一些少量使用 C 操作更方面的逻辑，结合放在 Lua 中作为源代码发布出去，使用的时候，先编译加载动态库，也是一个方案。

#category Programming


#p0
#date 20年10月11日 周二 02:12

## DNS service 重构

将 rpc_framework 中 [service_dns](https://github.com/lalawue/rpc_framework/tree/master/apps/service_dns) 网络层的控制从 C 层移到了 Lua 层，C 层只负责 UDP 包的数据拼接、解包，将代码统一到了 [m_dnsutils](https://github.com/lalawue/m_dnsutils) 里。

在减少了大量 C 跟 Lua 的交互后，两者算是各自做了自己擅长的方面，自测后的效果也不错。

#category Programming